<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io</link></image><lastBuildDate>Sat, 06 Sep 2025 09:25:57 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>Spring Cloud Alibaba 笔记</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud%20Alibaba%20-bi-ji.html</link><description># Spring Cloud Alibaba

## 一、注册中心-Nacos（AP）

### 1、[官方wiki](https://nacos.io/zh-cn/docs/what-is-nacos.html)

### 2、主要功能
![](https://img-blog.csdnimg.cn/1013e6f1566b4d569ce994e3dcaab86c.png)

服务的注册与发现是由 `Nacos discovery` 组件来实现的！ 其核心功能：
1. 服务的注册： Nacos-client发送REST请求向Nacos-server注册自己的服务，包括ip地址、端口、健康检查URL等元信息，收到后存在一个双层的内存map注册表中，当然你也可以存在MySQL关系型数据库中！
2. 服务的心跳：默认5s一次；
3. 服务同步：Nacos集群中的互相同步服务实例；
4. 服务发现：消费者在调用提供者时，也会发REST请求定时拉取注册服务清单，并且缓存在本地；
5. 服务健康检查：Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud%20Alibaba%20-bi-ji.html</guid><pubDate>Sat, 06 Sep 2025 09:25:27 +0000</pubDate></item><item><title>分布式事务六种解决方案</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/fen-bu-shi-shi-wu-liu-zhong-jie-jue-fang-an.html</link><description>## 一、前言
事务想必大家并不陌生，至于什么是 ACID，也是老生常谈了。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/fen-bu-shi-shi-wu-liu-zhong-jie-jue-fang-an.html</guid><pubDate>Sat, 06 Sep 2025 09:24:41 +0000</pubDate></item><item><title>深入浅出搞懂Nginx</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/shen-ru-qian-chu-gao-dong-Nginx.html</link><description>## 1. 什么是Nginx？


Nginx是一个**轻量级/高性能**的反向代理Web服务器，他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如：新浪、网易、 腾讯等。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/shen-ru-qian-chu-gao-dong-Nginx.html</guid><pubDate>Sat, 06 Sep 2025 09:24:00 +0000</pubDate></item><item><title>AopContext.currentProxy()？还可以这样用！</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/AopContext.currentProxy%28%29%EF%BC%9F-huan-ke-yi-zhe-yang-yong-%EF%BC%81.html</link><description>### 0 由来

今天在开发中发现学习到了一点，如果在方法A的逻辑代码处理后，需要对同一个数据库表多次操作，或者对不同数据库表操作需要添加事务，但是为了代码的完备性，需要单独把最后的数据库操作代码拿出来放到方法B中。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/AopContext.currentProxy%28%29%EF%BC%9F-huan-ke-yi-zhe-yang-yong-%EF%BC%81.html</guid><pubDate>Sat, 06 Sep 2025 09:23:20 +0000</pubDate></item><item><title>Java中遍历HashMap的5种方式</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-bian-li-HashMap-de-5-zhong-fang-shi.html</link><description>### 0 简介
1. 本教程将为你展示Java中HashMap的几种典型遍历方式，在实际开发中十分有用，我最喜欢的就是ForEach或者Lambda。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-bian-li-HashMap-de-5-zhong-fang-shi.html</guid><pubDate>Sat, 06 Sep 2025 09:22:50 +0000</pubDate></item><item><title>食堂系统</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/shi-tang-xi-tong.html</link><description>## 一、分布式事务

### 1. 采用本地消息表来解决分布式事务
- A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
- 接着 A 系统将这个消息发送到 MQ 中去（**或者使用open feign进行远程调用**）；
- B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息（**也或者直接是通过远程调用后的幂等性判断**）；
- B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态（这里特别需要修改A系统的消息表状态）；
- 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理（**会有一个重试失败次数，如果超过规定数就会发送消息到开发者手动处理**）；
- 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/shi-tang-xi-tong.html</guid><pubDate>Sat, 06 Sep 2025 09:22:16 +0000</pubDate></item><item><title>物联网中台PRD</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/wu-lian-wang-zhong-tai-PRD.html</link><description>## 一、需求背景
- Y项目将要接入多种硬件设备，在开发、测试、生产几个不同的阶段，设备需要接入不同的软件环境，基于多租户的设备中心只能部署在单一环境中，无法解决设备在不同环境之间分配和切换的问题。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/wu-lian-wang-zhong-tai-PRD.html</guid><pubDate>Sat, 06 Sep 2025 09:21:45 +0000</pubDate></item><item><title>电商开放平台：订单库扩容实战</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/dian-shang-kai-fang-ping-tai-%EF%BC%9A-ding-dan-ku-kuo-rong-shi-zhan.html</link><description>&gt; 文章摘要：**随着电商业务越做越大，原来开放平台的 10 库的容量日益满足不了业务快速发展的需要，为了保障今年 11 月份大促后库业务正常运行，需要提前把订单库的 10 库扩容为 50 库。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/dian-shang-kai-fang-ping-tai-%EF%BC%9A-ding-dan-ku-kuo-rong-shi-zhan.html</guid><pubDate>Sat, 06 Sep 2025 09:20:15 +0000</pubDate></item><item><title>物联网中台的验签环节</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/wu-lian-wang-zhong-tai-de-yan-qian-huan-jie.html</link><description>## 简介

- X项目将要接入多种硬件设备，在开发、测试、生产几个不同的阶段，设备需要接入不同的软件环境，基于多租户的设备中心只能部署在单一环境中，无法解决设备在不同环境之间分配和切换的问题。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/wu-lian-wang-zhong-tai-de-yan-qian-huan-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:19:07 +0000</pubDate></item><item><title>他人商场秒杀项目总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/ta-ren-shang-chang-miao-sha-xiang-mu-zong-jie.html</link><description>## 项目相关博客汇总
1、[【商城秒杀项目】-- 概况](https://blog.csdn.net/weixin_42687829/article/details/104412810)

2、[【商城秒杀项目】-- 对返回json结果的封装、通用缓存Key的设计与封装](https://blog.csdn.net/weixin_42687829/article/details/104428085)

3、[【商城秒杀项目】-- 登录时使用两次MD5加密](https://blog.csdn.net/weixin_42687829/article/details/104432048)

4、[【商城秒杀项目】-- 使用JSR303进行参数校验、全局异常处理](https://blog.csdn.net/weixin_42687829/article/details/104442722)

5、[【商城秒杀项目】-- 分布式Session的实现、使用Aop校验Token令牌](https://blog.csdn.net/weixin_42687829/article/details/104445741)

6、[【商城秒杀项目】-- 流量削峰应该怎么做](https://blog.csdn.net/weixin_42687829/article/details/104455580)

7、[【商城秒杀项目】-- 页面缓存、URL缓存、对象缓存](https://blog.csdn.net/weixin_42687829/article/details/104478037)

8、[【商城秒杀项目】-- 页面伪静态化](https://blog.csdn.net/weixin_42687829/article/details/104482236)

9、[【商城秒杀项目】-- 秒杀的业务逻辑、接口的优化](https://blog.csdn.net/weixin_42687829/article/details/104493180)

10、[【商城秒杀项目】-- 使用rabbitmq异步下单](https://blog.csdn.net/weixin_42687829/article/details/104497733)

11、[【商城秒杀项目】-- 秒杀接口地址隐藏](https://blog.csdn.net/weixin_42687829/article/details/104512299)

12、[【商城秒杀项目】-- 使用数学图形验证码来进行限流](https://blog.csdn.net/weixin_42687829/article/details/104515151)

13、[【商城秒杀项目】-- 接口限流防刷](https://blog.csdn.net/weixin_42687829/article/details/104516751)

14、[关于springboot项目使用@Transactional注解事务不回滚的问题](https://blog.csdn.net/weixin_42687829/article/details/104414967)

## 一、项目的亮点
- 使用分布式Seesion，实现让多台服务器同时可以响应
- 使用redis做缓存提高访问速度和并发量，减少数据库压力，利用内存标记减少redis的访问
- 使用页面静态化，加快用户访问速度，提高QPS（每秒查询率），缓存页面至浏览器，前后端分离降低服务器的压力
- 使用消息队列完成异步下单，提升用户体验，削峰和限流
- 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码


## 二、主要知识点

### 2.1 分布式Seesion

&gt; **通常秒杀服务实际的应用可能不止部署在一个服务器上，而是分布式的部署在多台服务器，这时候假如用户登录是在第一个服务器，第一个请求到了第一台服务器，这时是没问题的，但是第二个请求到了第二个服务器，那么用户的session信息就丢失了，于是需要使用分布式session来进行处理?**

**解决：session同步，无论访问哪一台服务器，session都可以取得到，利用redis缓存的方法，另外使用一个redis服务器专门用于存放用户的session信息，这样就不会出现用户session丢失的情况（每次需要session，从缓存中取即可）**

### 2.2 使用redis缓解数据库压力

**本项目大量的使用了缓存技术，包括用户信息缓存（分布式session），商品信息的缓存，商品库存缓存，订单的缓存，页面缓存，对象缓存等来减少了对数据库服务器的访问?**

### 2.3 通用缓存key封装

&gt; **大量的缓存引用也出现了一个问题，如何识别不同模块中的缓存（即key值重复，如何辨别是不同模块的key）**

**解决：利用一个抽象类，定义BaseKey（前缀），在里面定义缓存key的前缀以及缓存的过期时间从而实现将缓存的key进行封装；让不同模块继承它，这样每次存入一个模块的缓存的时候，就加上这个缓存特定的前缀，以及统一制定不同的过期时间**

### 2.4 页面静态化（前后端分离）

**页面静态化的主要目的是为了加快页面的加载速度，将商品的详情和订单详情页面做成静态HTML（纯的HTML），数据的加载只需要通过ajax来请求服务器，并且做了静态化HTML页面可以缓存在客户端的浏览器;**

### 2.5 消息队列完成异步下单

**使用消息队列完成异步下单，可以提升用户体验、削峰和限流**

## 三、使用思路

1. 系统初始化的时候，把商品库存数量加载到Redis里面去
2. 后端收到秒杀请求，先Redis预减库存，如果库存已经到达临界值的时候，就不需要继续请求下去，直接返回秒杀失败，即后面的大量请求无需给系统带来压力
3. 判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀
4. 库存充足，且无重复秒杀，将秒杀请求封装后放入消息队列，同时给前端返回一个code (0)，即代表返回排队中（返回的并不是失败或者成功，此时还不能判断）
5. 前端接收到数据后，显示排队中，并根据商品id轮询请求服务器查询秒杀的结果（考虑200ms轮询一次）
6. 后端RabbitMQ监听秒杀MIAOSHA_QUEUE这个名字的通道，如果有消息过来，就获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）
7. 此时，前端根据商品id轮询请求接口result，查看是否生成了商品订单，如果请求返回-1就代表秒杀失败，返回0就代表排队中，返回&gt;0就代表秒杀成功
8. 安全性优化：双重md5密码校验、秒杀接口地址的隐藏、接口限流防刷、数学公式验证码

## 四、优雅的代码编写

**对接口的输出结果做了一个Result封装、对错误的代码做了一个CodeMsg封装、对访问缓存做了一个key的封装**

## 五、项目难点及问题解决

### 5.1 使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？

&gt; 缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库

**解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤**

缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库
解决方案：为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用；也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩

例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的时候更新缓存时间，这样每次取session，都会延长30分钟，相对来说，就减少了缓存过期的几率

**缓存一致性要求数据更新的同时缓存数据也能够实时更新?**

解决方案：在数据更新的同时立即去更新缓存，首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回；在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）

### 5.2 大量的使用缓存，对于缓存服务器也有很大的压力，如何减少redis的访问?

在redis预减库存的时候，内存中维护一个localOverMap作为内存标记，当没有库存的时候，将其设置为true；每次秒杀业务访问redis之前，先查一下map标记，如果为true说明没有库存，就直接返回秒杀失败，无需再去请求redis服务器

### 5.3 在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积的情况?

使用消息队列来异步处理请求，每次请求过来先不去处理请求，而是放入消息队列，然后在后台设置一个监听器，分别监听不同业务的消息队列，有消息来的时候才进行秒杀业务逻辑，这样防止多个请求同时操作的时候，出现数据库连接过多的异常

### 5.4 怎么保证一个用户不能重复下单?

在秒杀订单表中建立一个唯一索引（由用户Id与商品Id组成），使得同一条记录只能入库一次，防止一个用户同时发出多个请求秒杀到多个商品

唯一索引是在数据库表结构中对字段添加唯一索引后数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/ta-ren-shang-chang-miao-sha-xiang-mu-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:18:12 +0000</pubDate></item><item><title>kafka生产者源码分析3-Producer核心流程分析（重要）</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/kafka-sheng-chan-zhe-yuan-ma-fen-xi-3-Producer-he-xin-liu-cheng-fen-xi-%EF%BC%88-zhong-yao-%EF%BC%89.html</link><description>&gt; **文章摘要：本文主要分析Producer核心流程**

本文分析使用kafka-0.10.2.0的源码，书接上文[kafka生产者源码分析2-Producer初始化](http://121.199.72.143:8090/archives/kafka-sheng-chan-zhe-yuan-ma-fen-xi-2-producer-chu-shi-hua)，本篇重点分析Producer核心流程。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/kafka-sheng-chan-zhe-yuan-ma-fen-xi-3-Producer-he-xin-liu-cheng-fen-xi-%EF%BC%88-zhong-yao-%EF%BC%89.html</guid><pubDate>Sat, 06 Sep 2025 09:17:25 +0000</pubDate></item><item><title>springboot配置线程池及其使用(特别是使用场景)</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/springboot-pei-zhi-xian-cheng-chi-ji-qi-shi-yong-%28-te-bie-shi-shi-yong-chang-jing-%29.html</link><description>## 前言
最近在做订单模块，用户购买产品之后，需要经过Kafak中间件发送后消费，下单成功之后需要给用户发送提醒短信。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/springboot-pei-zhi-xian-cheng-chi-ji-qi-shi-yong-%28-te-bie-shi-shi-yong-chang-jing-%29.html</guid><pubDate>Sat, 06 Sep 2025 09:16:41 +0000</pubDate></item><item><title>MySql逻辑结构简介</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySql-luo-ji-jie-gou-jian-jie.html</link><description>**今天安装了数据库，系统学习mysql数据库的底层结构！**

**结构示意图：**

![image.png](/upload/2022/01/image-369162918f234105b19c2c3aecb6dc1c.png)

**如上图，可把数据库的结构分成四层，见下图及文字说明：**

![image.png](/upload/2022/01/image-c8af28dc8134459bac1158c755bc3cab.png)

**简洁图**

![](https://img-blog.csdnimg.cn/b776572121094706ad0c4a0de0240b16.png)

### 一、连接层
- 提供客户端和连接服务，包含本地Sock通信和大多数基于客户端/服务端工具实现的**类似于TCP/IP的通信**，主要完成一些类似于**连接处理、授权认证、及相关的安全方案**，在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程，同样在该层上可以实现基于SSL的安全链接。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySql-luo-ji-jie-gou-jian-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:16:07 +0000</pubDate></item><item><title>利用 Lua 脚本在 Redis 中实现秒杀商品减库存</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/li-yong-%20Lua%20-jiao-ben-zai-%20Redis%20-zhong-shi-xian-miao-sha-shang-pin-jian-ku-cun.html</link><description>
### 一、情景描述 

公司开展商品秒杀活动，共有 A、B、C、D 四个商品提供秒杀抢购，每件商品限售 5 件，售完即止。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/li-yong-%20Lua%20-jiao-ben-zai-%20Redis%20-zhong-shi-xian-miao-sha-shang-pin-jian-ku-cun.html</guid><pubDate>Sat, 06 Sep 2025 09:15:38 +0000</pubDate></item><item><title>JVM垃圾回收</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/JVM-la-ji-hui-shou.html</link><description>&lt;!-- @import '[TOC]' {cmd='toc' depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

- [JVM 垃圾回收](#jvm-垃圾回收)
  - [写在前面](#写在前面)
    - [本节常见面试题](#本节常见面试题)
    - [本文导火索](#本文导火索)
  - [1 揭开 JVM 内存分配与回收的神秘面纱](#1-揭开-jvm-内存分配与回收的神秘面纱)
    - [1.1 对象优先在 eden 区分配](#11-对象优先在-eden-区分配)
    - [1.2 大对象直接进入老年代](#12-大对象直接进入老年代)
    - [1.3 长期存活的对象将进入老年代](#13-长期存活的对象将进入老年代)
    - [1.4 动态对象年龄判定](#14-动态对象年龄判定)
    - [1.5 主要进行 gc 的区域](#15-主要进行-gc-的区域)
  - [2 对象已经死亡？](#2-对象已经死亡)
    - [2.1 引用计数法](#21-引用计数法)
    - [2.2 可达性分析算法](#22-可达性分析算法)
    - [2.3 再谈引用](#23-再谈引用)
    - [2.4 不可达的对象并非“非死不可”](#24-不可达的对象并非非死不可)
    - [2.5 如何判断一个常量是废弃常量？](#25-如何判断一个常量是废弃常量)
    - [2.6 如何判断一个类是无用的类](#26-如何判断一个类是无用的类)
  - [3 垃圾收集算法](#3-垃圾收集算法)
    - [3.1 标记-清除算法](#31-标记-清除算法)
    - [3.2 标记-复制算法](#32-标记-复制算法)
    - [3.3 标记-整理算法](#33-标记-整理算法)
    - [3.4 分代收集算法](#34-分代收集算法)
  - [4 垃圾收集器](#4-垃圾收集器)
    - [4.1 Serial 收集器](#41-serial-收集器)
    - [4.2 ParNew 收集器](#42-parnew-收集器)
    - [4.3 Parallel Scavenge 收集器](#43-parallel-scavenge-收集器)
    - [4.4.Serial Old 收集器](#44serial-old-收集器)
    - [4.5 Parallel Old 收集器](#45-parallel-old-收集器)
    - [4.6 CMS 收集器](#46-cms-收集器)
    - [4.7 G1 收集器](#47-g1-收集器)
    - [4.8 ZGC 收集器](#48-zgc-收集器)
  - [参考](#参考)

&lt;!-- /code_chunk_output --&gt;


# JVM 垃圾回收

## 写在前面

### 本节常见面试题

问题答案在文中都有提到

- 如何判断对象是否死亡（两种方法）。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/JVM-la-ji-hui-shou.html</guid><pubDate>Sat, 06 Sep 2025 09:14:32 +0000</pubDate></item><item><title>详解ThreadLocal关键字</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/xiang-jie-ThreadLocal-guan-jian-zi.html</link><description>&gt; 本文来自一枝花算不算浪漫投稿， 原文地址：[https://juejin.im/post/5eacc1c75188256d976df748](https://juejin.im/post/5eacc1c75188256d976df748)。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/xiang-jie-ThreadLocal-guan-jian-zi.html</guid><pubDate>Sat, 06 Sep 2025 09:14:00 +0000</pubDate></item><item><title>HashMap(JDK1.8)源码+底层数据结构分析</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/HashMap%28JDK1.8%29-yuan-ma-%2B-di-ceng-shu-ju-jie-gou-fen-xi.html</link><description>参考与：https://mp.weixin.qq.com/s/0Gf2DzuzgEx0i3mHVvhKNQ

&gt; ### 问：hashMap中hash冲突后，新的Entry节点在插入链表的时候，是怎么插入的么？

**java8之前是头插法**，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，因为写这个代码的作者认为**后来的值被查找的可能性更大一点，提升查找的效率。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/HashMap%28JDK1.8%29-yuan-ma-%2B-di-ceng-shu-ju-jie-gou-fen-xi.html</guid><pubDate>Sat, 06 Sep 2025 09:13:08 +0000</pubDate></item><item><title>读写分离&amp;分库分表常见问题</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/du-xie-fen-li-%26-fen-ku-fen-biao-chang-jian-wen-ti.html</link><description>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/du-xie-fen-li-%26-fen-ku-fen-biao-chang-jian-wen-ti.html</guid><pubDate>Sat, 06 Sep 2025 09:12:37 +0000</pubDate></item><item><title>Spring Cloud</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud.html</link><description>&gt; 本文基于 Spring Cloud Netflix 。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud.html</guid><pubDate>Sat, 06 Sep 2025 09:11:43 +0000</pubDate></item><item><title>Kafka常见面试总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Kafka-chang-jian-mian-shi-zong-jie.html</link><description>
## Kafka面试题总结

### 一、Kafka 是什么？主要应用场景有哪些？

&gt; **如何回答：1.kafka由哪几部分组成？2.应用的场景？（异步，解耦，消峰）3.引入后产生的一列问题和注意事项？**

Kafka 是一个分布式流式处理平台。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Kafka-chang-jian-mian-shi-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:10:56 +0000</pubDate></item><item><title>Redis常见问题总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Redis-chang-jian-wen-ti-zong-jie.html</link><description>
### 参考文献：
[Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
[整理好了，Redis面试题(重要)](https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA)
[Redis常见面试题](https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ)
[Redis为什么变慢了？一文讲透如何排查Redis性能问题](https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw)
[Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？](https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g)
[缓存一致性问题怎么解决？](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)

## 一、简单介绍一下 Redis 呗!
如何回答：1.key-value结构存储的非关系型数据库；2.优点：内存存储、丰富数据结构、单线程IO、支持持久化；3.场景：分布式缓存、分布式锁、分布式队列、排行榜、查找附近的人等等；

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Redis-chang-jian-wen-ti-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:10:13 +0000</pubDate></item><item><title>Zookeeper分布式协调服务</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Zookeeper-fen-bu-shi-xie-diao-fu-wu.html</link><description>## 一、分布式的基本概念

### 1.1 系统高可用
所谓的系统高可用，主要是指两个方面：
- 系统的健壮性, 不允许系统出现单点故障；
- 系统的处理能力, 可以提高系统的处理能力, 保证系统的运行效率

**集群**
 所谓的集群, 主要是原来使用的是一台服务器处理, 现在使用多台服务器保障系统的运行，主要分为：

- **主备集群:** 主要有一个主要节点提供服务, 另外的节点主要是出于备份状态, 平时不提供工作, 一旦主节点出现问题, 备份节点启动运行, 提供正常的服务；

![QQ图片20211005131557.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131557-63e5f8b0303f4921a8ddc066f5491de4.png)

- **主从集群:** 集群中的节点都提供服务, 但是每台服务器的角色可能不一样, 比如配置数据库的读写分离, 主数据库可能是写操作, 对于实时性要求不高的读操作就使用从数据库，该模式对于主从有数据传输延迟性；

![QQ图片20211005131606.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131606-2462413ea43e4b3195c95989cd2e1f96.png)

- **普通集群:** 集群中的节点提供的功能是一样的, 所有的节点没有主从之分,主要是提高系统的高可用；

![QQ图片20211005131608.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131608-fd7c58a463614a1dbb26b212de33740c.png)

**分布式**

分布式是系统部署方式：
- 比如我们的业务系统, 部署一个业务系统需要的环境(应用服务(Tomcat)+数据库服务(MySQL))；

- 如果我们把Tomcat和数据库MySQL服务部署在同一台服务器, 我们称之为单机部署, 这样Tomcat和MySQL之间的网络开销可以忽略(直接走127.0.0.1不会消耗网络)；

- 如果我们把Tomcat和数据库MySQL服务部署在不同的服务器, 我们称之为分布式应用, 因为应用服务器和数据库服务器之间需要走网络通信, 当然, **我们把所有需要走网络这种部署方式称之为'分布式应用'**；

![QQ图片20211005132216.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005132216-e8540e32c1da481899ca7203721bf30b.png)

**微服务**
当使用单体应用时：其中一个模块挂了，整个系统（crm）都会访问不了；如果只是针对整个jar包（crm.jar）部署的话，就没法针对高并发模块进行单独的增强扩容或者添加服务器了；对于系统维护/后期开发不方便，若想要单独操作一个模块，需要把整个系统停掉，导致其他模块不可用。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Zookeeper-fen-bu-shi-xie-diao-fu-wu.html</guid><pubDate>Sat, 06 Sep 2025 09:08:15 +0000</pubDate></item><item><title>SpringBoot项目汇总</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-xiang-mu-hui-zong.html</link><description>## 一、项目简述

### 企业开发中常见的后台管理系统？

**CRM（客户关系管理）：**  管理客户信息，如个人信息、订单信息等；

![QQ图片20210928140559.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140559-5ded626505dc4242a5e30a8f297b9d87.png)

**OA（办公自动化）：** 基于工作流概念，使企业内部人员方便快捷地共享信息，高效协同工作；

![QQ图片20210928140611.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140611-b584b2a7e9c343e3b5feb97319cc1604.png)

**ERP（企业资源计划）：** 物资资源管理、人力资源管理、财务资源管理、信息资源管理等集成一体化；

![QQ图片20210928140615.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140615-e3a4ef17394348d5b4509566c6f7d8a9.png)

### 基础构建

**1. pom.xml依赖：** Spring单元测试、数据库、AOP、后端校验、接口文档Springfox、对象转换、验证码、缓存、权限控制Shiro等等。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-xiang-mu-hui-zong.html</guid><pubDate>Sat, 06 Sep 2025 09:07:16 +0000</pubDate></item><item><title>SpringBoot的自动装配原理</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-de-zi-dong-zhuang-pei-yuan-li.html</link><description>## 前言

我觉得我们可以从以下几个方面回答：
1. 什么是 SpringBoot 自动装配？
2. SpringBoot 是如何实现自动装配的？如何实现按需加载？
3. 如何实现一个 Starter？

使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-de-zi-dong-zhuang-pei-yuan-li.html</guid><pubDate>Sat, 06 Sep 2025 09:06:40 +0000</pubDate></item><item><title>SpringBoot实现拦截器Interceptor</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-shi-xian-lan-jie-qi-Interceptor.html</link><description>&gt; 本文大部分内容是对国外一个不错的文章 ：https://o7planning.org/en/11689/spring-boot-interceptors-tutorial 的翻译，做了适当的修改。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-shi-xian-lan-jie-qi-Interceptor.html</guid><pubDate>Sat, 06 Sep 2025 09:05:49 +0000</pubDate></item><item><title>Spring Boot</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Boot.html</link><description>## **SpingBoot - Maven补充**

### **一、依赖冲突**

![QQ图片20210925161432.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210925161432-2bd4801c2b3f4e1992be661f96a0027c.png)

**如何解决依赖冲突？**

&gt; 方法一：默认情况下：优先保留前面先声明的版本，所以就算出现的依赖冲突但整个项目运行中是不会报错的，Maven已经自动处理好了！

&gt; 方法二：单独为依赖库增加`dependency`指定版本号，就如依赖冲突例子可得，可以直接在dependencies中添加spring-beans的版本！

&gt; 方法三：使用`exclusion`排除某个依赖，比如在添加spring-webmvc依赖时，使用属性标签`exclusion`排除`spring-beans`，这样`spring-beans`版本只能选择`spring-jdbc`的版本了！

&gt; 方法四(最常用的解决方案)：使用`dependencyManagement`锁定依赖库的版本号，注意该方法只能声明版本号，不能真正下载导入依赖库！


### **二、分模块构建项目**
项目规模比较庞大时，可以考虑对项目进行拆分，分模块进行构建项目，有2种常见的拆分思路：按业务模块：员工模块、部门模块、工资模块等；按层：dao层、service层、web层等。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Boot.html</guid><pubDate>Sat, 06 Sep 2025 09:05:08 +0000</pubDate></item><item><title>Spring 框架设计模式</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20-kuang-jia-she-ji-mo-shi.html</link><description>&lt;!-- TOC --&gt;

- [控制反转(IoC)和依赖注入(DI)](#控制反转ioc和依赖注入di)
- [工厂设计模式](#工厂设计模式)
- [单例设计模式](#单例设计模式)
- [代理设计模式](#代理设计模式)
    - [代理模式在 AOP 中的应用](#代理模式在-aop-中的应用)
    - [Spring AOP 和 AspectJ AOP 有什么区别?](#spring-aop-和-aspectj-aop-有什么区别)
- [模板方法](#模板方法)
- [观察者模式](#观察者模式)
    - [Spring 事件驱动模型中的三种角色](#spring-事件驱动模型中的三种角色)
        - [事件角色](#事件角色)
        - [事件监听者角色](#事件监听者角色)
        - [事件发布者角色](#事件发布者角色)
    - [Spring 的事件流程总结](#spring-的事件流程总结)
- [适配器模式](#适配器模式)
    - [spring AOP中的适配器模式](#spring-aop中的适配器模式)
    - [spring MVC中的适配器模式](#spring-mvc中的适配器模式)
- [装饰者模式](#装饰者模式)
- [总结](#总结)
- [参考](#参考)

&lt;!-- /TOC --&gt;

### 参考文献：[设计模式目录](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)

## **Spring 框架中用到了哪些设计模式？**

关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章[《面试官:“谈谈 Spring 中都用到了那些设计模式?”。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20-kuang-jia-she-ji-mo-shi.html</guid><pubDate>Sat, 06 Sep 2025 09:04:36 +0000</pubDate></item><item><title>Spring</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring.html</link><description>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！

下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring.html</guid><pubDate>Sat, 06 Sep 2025 09:03:49 +0000</pubDate></item><item><title>MySQL数据库索引</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-shu-ju-ku-suo-yin.html</link><description>## 一、何为索引？有什么作用？**

**索引是一种用于快速查询和检索数据的数据结构。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-shu-ju-ku-suo-yin.html</guid><pubDate>Sat, 06 Sep 2025 09:02:56 +0000</pubDate></item><item><title>并发进阶总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/bing-fa-jin-jie-zong-jie.html</link><description>&lt;!-- @import '[TOC]' {cmd='toc' depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

- [Java 并发进阶常见面试题总结](#java-并发进阶常见面试题总结)
  - [1.synchronized 关键字](#1synchronized-关键字)
    - [1.1.说一说自己对于 synchronized 关键字的了解](#11说一说自己对于-synchronized-关键字的了解)
    - [1.2. 说说自己是怎么使用 synchronized 关键字](#12-说说自己是怎么使用-synchronized-关键字)
    - [1.3. 构造方法可以使用 synchronized 关键字修饰么？](#13-构造方法可以使用-synchronized-关键字修饰么)
    - [1.3. 讲一下 synchronized 关键字的底层原理](#13-讲一下-synchronized-关键字的底层原理)
      - [1.3.1. synchronized 同步语句块的情况](#131-synchronized-同步语句块的情况)
      - [1.3.2. synchronized 修饰方法的的情况](#132-synchronized-修饰方法的的情况)
      - [1.3.3.总结](#133总结)
    - [1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗](#14-说说-jdk16-之后的-synchronized-关键字底层做了哪些优化可以详细介绍一下这些优化吗)
    - [1.5. 谈谈 synchronized 和 ReentrantLock 的区别](#15-谈谈-synchronized-和-reentrantlock-的区别)
      - [1.5.1. 两者都是可重入锁](#151-两者都是可重入锁)
      - [1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API](#152synchronized-依赖于-jvm-而-reentrantlock-依赖于-api)
      - [1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能](#153reentrantlock-比-synchronized-增加了一些高级功能)
  - [2. volatile 关键字](#2-volatile-关键字)
    - [2.1. CPU 缓存模型](#21-cpu-缓存模型)
    - [2.2. 讲一下 JMM(Java 内存模型)](#22-讲一下-jmmjava-内存模型)
    - [2.3. 并发编程的三个重要特性](#23-并发编程的三个重要特性)
    - [2.4. 说说 synchronized 关键字和 volatile 关键字的区别](#24-说说-synchronized-关键字和-volatile-关键字的区别)
  - [3. ThreadLocal](#3-threadlocal)
    - [3.1. ThreadLocal 简介](#31-threadlocal-简介)
    - [3.2. ThreadLocal 示例](#32-threadlocal-示例)
    - [3.3. ThreadLocal 原理](#33-threadlocal-原理)
    - [3.4. ThreadLocal 内存泄露问题](#34-threadlocal-内存泄露问题)
  - [4. 线程池](#4-线程池)
    - [4.1. 为什么要用线程池？](#41-为什么要用线程池)
    - [4.2. 实现 Runnable 接口和 Callable 接口的区别](#42-实现-runnable-接口和-callable-接口的区别)
    - [4.3. 执行 execute()方法和 submit()方法的区别是什么呢？](#43-执行-execute方法和-submit方法的区别是什么呢)
    - [4.4. 如何创建线程池](#44-如何创建线程池)
    - [4.5 ThreadPoolExecutor 类分析](#45-threadpoolexecutor-类分析)
      - [4.5.1 `ThreadPoolExecutor`构造函数重要参数分析](#451-threadpoolexecutor构造函数重要参数分析)
      - [4.5.2 `ThreadPoolExecutor` 饱和策略](#452-threadpoolexecutor-饱和策略)
    - [4.6 一个简单的线程池 Demo](#46-一个简单的线程池-demo)
    - [4.7 线程池原理分析](#47-线程池原理分析)
  - [5. Atomic 原子类](#5-atomic-原子类)
    - [5.1. 介绍一下 Atomic 原子类](#51-介绍一下-atomic-原子类)
    - [5.2. JUC 包中的原子类是哪 4 类?](#52-juc-包中的原子类是哪-4-类)
    - [5.3. 讲讲 AtomicInteger 的使用](#53-讲讲-atomicinteger-的使用)
    - [5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理](#54-能不能给我简单介绍一下-atomicinteger-类的原理)
  - [6. AQS](#6-aqs)
    - [6.1. AQS 介绍](#61-aqs-介绍)
    - [6.2. AQS 原理分析](#62-aqs-原理分析)
      - [6.2.1. AQS 原理概览](#621-aqs-原理概览)
      - [6.2.2. AQS 对资源的共享方式](#622-aqs-对资源的共享方式)
      - [6.2.3. AQS 底层使用了模板方法模式](#623-aqs-底层使用了模板方法模式)
    - [6.3. AQS 组件总结](#63-aqs-组件总结)
    - [6.4. 用过 CountDownLatch 么？什么场景下用的？](#64-用过-countdownlatch-么什么场景下用的)
  - [7 Reference](#7-reference)

&lt;!-- /code_chunk_output --&gt;


# **Java 并发进阶常见面试题总结**

## **1.synchronized 关键字**

![synchronized关键字.png](/upload/2021/10/synchronized%E5%85%B3%E9%94%AE%E5%AD%97-bf5a1263796649aba1b54cc9201a40a6.png)

&gt; ### 问：知道synchronized原理吗？

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/bing-fa-jin-jie-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:02:26 +0000</pubDate></item><item><title>Java并发基础总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-bing-fa-ji-chu-zong-jie.html</link><description>&lt;!-- TOC --&gt;

- [Java 并发基础常见面试题总结](#Java-并发基础常见面试题总结)
  - [1. 什么是线程和进程?](#1-什么是线程和进程)
    - [1.1. 何为进程?](#11-何为进程)
    - [1.2. 何为线程?](#12-何为线程)
  - [2. 请简要描述线程与进程的关系,区别及优缺点？](#2-请简要描述线程与进程的关系区别及优缺点)
    - [2.1. 图解进程和线程的关系](#21-图解进程和线程的关系)
    - [2.2. 程序计数器为什么是私有的?](#22-程序计数器为什么是私有的)
    - [2.3. 虚拟机栈和本地方法栈为什么是私有的?](#23-虚拟机栈和本地方法栈为什么是私有的)
    - [2.4. 一句话简单了解堆和方法区](#24-一句话简单了解堆和方法区)
  - [3. 说说并发与并行的区别?](#3-说说并发与并行的区别)
  - [4. 为什么要使用多线程呢?](#4-为什么要使用多线程呢)
  - [5. 使用多线程可能带来什么问题?](#5-使用多线程可能带来什么问题)
  - [6. 说说线程的生命周期和状态?](#6-说说线程的生命周期和状态)
  - [7. 什么是上下文切换?](#7-什么是上下文切换)
  - [8. 什么是线程死锁?如何避免死锁?](#8-什么是线程死锁如何避免死锁)
    - [8.1. 认识线程死锁](#81-认识线程死锁)
    - [8.2. 如何避免线程死锁?](#82-如何避免线程死锁)
  - [9. 说说 sleep() 方法和 wait() 方法区别和共同点?](#9-说说-sleep-方法和-wait-方法区别和共同点)
  - [10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？](#10-为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法)
  - [公众号](#公众号)

&lt;!-- /TOC --&gt;

# Java 并发基础常见面试题总结

### 参考文献：[Java 并发](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md)

## 1. 什么是线程和进程?

### 1.1. 何为进程?

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-bing-fa-ji-chu-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:01:45 +0000</pubDate></item><item><title>MyBatis基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MyBatis-ji-chu.html</link><description>## **基本使用**
#### **1.企业的流行框架**
SSM：Spring、SpringMVC、MyBatis
Apache Shiro
SpingBoot

#### **2.客户端请求流程**
- 客户端请求会先来到 `控制层Servlet/Controller`，再到 `业务层Service`，最后为 `数据持久层Dao`。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MyBatis-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 09:01:05 +0000</pubDate></item><item><title>MySQL的三大日志</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-de-san-da-ri-zhi.html</link><description>## **前言**

### 参考文档：[原来MySQL面试还会问这些...](https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ)

`MySQL日志` 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-de-san-da-ri-zhi.html</guid><pubDate>Sat, 06 Sep 2025 08:59:48 +0000</pubDate></item><item><title>MySQL优化规范</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-you-hua-gui-fan.html</link><description>&lt;!-- TOC --&gt;

- [数据库命令规范](#数据库命令规范)
- [数据库基本设计规范](#数据库基本设计规范)
    - [1. 所有表必须使用 Innodb 存储引擎](#1-所有表必须使用-innodb-存储引擎)
    - [2. 数据库和表的字符集统一使用 UTF8](#2-数据库和表的字符集统一使用-utf8)
    - [3. 所有表和字段都需要添加注释](#3-所有表和字段都需要添加注释)
    - [4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-you-hua-gui-fan.html</guid><pubDate>Sat, 06 Sep 2025 08:58:57 +0000</pubDate></item><item><title>数据库知识概述</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/shu-ju-ku-zhi-shi-gai-shu.html</link><description>### 参考文献：[MySQL](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)、[SQL 练习](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md)、[SQL 语法](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md)

### **一、什么是数据库,数据库管理系统,数据库系统,数据库管理员?**

- **数据库** :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/shu-ju-ku-zhi-shi-gai-shu.html</guid><pubDate>Sat, 06 Sep 2025 08:58:05 +0000</pubDate></item><item><title>计算机网络基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/ji-suan-ji-wang-luo-ji-chu.html</link><description>### 参考文献：[HTTP](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md) ------ http方法、状态码、首部、https、http1.0/2.0；  

## 一 OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/ji-suan-ji-wang-luo-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 08:56:37 +0000</pubDate></item><item><title>Liunx基础操作</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Liunx-ji-chu-cao-zuo.html</link><description>### 参考文献：[Linux](https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md)

今天这篇文章中简单介绍一下一个 Java 程序员必知的 Linux 的一些概念以及常见命令。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Liunx-ji-chu-cao-zuo.html</guid><pubDate>Sat, 06 Sep 2025 08:55:57 +0000</pubDate></item><item><title>操作系统基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/cao-zuo-xi-tong-ji-chu.html</link><description>### 参考文献：[计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md)

大家好，我是帅哥！

这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/cao-zuo-xi-tong-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 08:54:40 +0000</pubDate></item><item><title>垃圾回收机制</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/la-ji-hui-shou-ji-zhi.html</link><description>## 前言
Java 相比 C/C++ 最显著的特点便是**引入了自动垃圾回收** (下文统一用 GC 指代自动垃圾回收)，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/la-ji-hui-shou-ji-zhi.html</guid><pubDate>Sat, 06 Sep 2025 08:53:10 +0000</pubDate></item><item><title>Java中那18 把锁</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-na-18%20-ba-suo.html</link><description>### [互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/6QrQ0TZVqSQq26Rms0_mvA)

## 一、乐观锁和悲观锁

### 1. 悲观锁

悲观锁对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-na-18%20-ba-suo.html</guid><pubDate>Sat, 06 Sep 2025 08:49:24 +0000</pubDate></item><item><title>RAG</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/RAG.html</link><description># 大模型知识问答RAG

## 一、RAG

&gt; **RAG主要涉及企业内部的文档数据，如果需要一些插件功能，只能需要外部Function calling调用等操作；**

大模型缺点：知识不是实时的、不知道私有领域的业务知识。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/RAG.html</guid><pubDate>Wed, 18 Jun 2025 10:57:45 +0000</pubDate></item><item><title>第一篇博客</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/di-yi-pian-bo-ke.html</link><description>## 第一

### 第二

- ![Image](https://github.com/user-attachments/assets/49178100-4fd3-41c1-8f76-15531692576e)

Retrieval-Augmented Generation（RAG） 将“检索”与“生成”结合，保障回答的 **事实准确性** 与 **自然表达**。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/di-yi-pian-bo-ke.html</guid><pubDate>Wed, 18 Jun 2025 10:54:31 +0000</pubDate></item></channel></rss>