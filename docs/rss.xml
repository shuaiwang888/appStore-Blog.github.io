<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io</link></image><lastBuildDate>Sat, 06 Sep 2025 09:17:52 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>kafka生产者源码分析3-Producer核心流程分析（重要）</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/kafka-sheng-chan-zhe-yuan-ma-fen-xi-3-Producer-he-xin-liu-cheng-fen-xi-%EF%BC%88-zhong-yao-%EF%BC%89.html</link><description>&gt; **文章摘要：本文主要分析Producer核心流程**

本文分析使用kafka-0.10.2.0的源码，书接上文[kafka生产者源码分析2-Producer初始化](http://121.199.72.143:8090/archives/kafka-sheng-chan-zhe-yuan-ma-fen-xi-2-producer-chu-shi-hua)，本篇重点分析Producer核心流程。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/kafka-sheng-chan-zhe-yuan-ma-fen-xi-3-Producer-he-xin-liu-cheng-fen-xi-%EF%BC%88-zhong-yao-%EF%BC%89.html</guid><pubDate>Sat, 06 Sep 2025 09:17:25 +0000</pubDate></item><item><title>springboot配置线程池及其使用(特别是使用场景)</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/springboot-pei-zhi-xian-cheng-chi-ji-qi-shi-yong-%28-te-bie-shi-shi-yong-chang-jing-%29.html</link><description>## 前言
最近在做订单模块，用户购买产品之后，需要经过Kafak中间件发送后消费，下单成功之后需要给用户发送提醒短信。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/springboot-pei-zhi-xian-cheng-chi-ji-qi-shi-yong-%28-te-bie-shi-shi-yong-chang-jing-%29.html</guid><pubDate>Sat, 06 Sep 2025 09:16:41 +0000</pubDate></item><item><title>MySql逻辑结构简介</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySql-luo-ji-jie-gou-jian-jie.html</link><description>**今天安装了数据库，系统学习mysql数据库的底层结构！**

**结构示意图：**

![image.png](/upload/2022/01/image-369162918f234105b19c2c3aecb6dc1c.png)

**如上图，可把数据库的结构分成四层，见下图及文字说明：**

![image.png](/upload/2022/01/image-c8af28dc8134459bac1158c755bc3cab.png)

**简洁图**

![](https://img-blog.csdnimg.cn/b776572121094706ad0c4a0de0240b16.png)

### 一、连接层
- 提供客户端和连接服务，包含本地Sock通信和大多数基于客户端/服务端工具实现的**类似于TCP/IP的通信**，主要完成一些类似于**连接处理、授权认证、及相关的安全方案**，在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程，同样在该层上可以实现基于SSL的安全链接。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySql-luo-ji-jie-gou-jian-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:16:07 +0000</pubDate></item><item><title>利用 Lua 脚本在 Redis 中实现秒杀商品减库存</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/li-yong-%20Lua%20-jiao-ben-zai-%20Redis%20-zhong-shi-xian-miao-sha-shang-pin-jian-ku-cun.html</link><description>
### 一、情景描述 

公司开展商品秒杀活动，共有 A、B、C、D 四个商品提供秒杀抢购，每件商品限售 5 件，售完即止。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/li-yong-%20Lua%20-jiao-ben-zai-%20Redis%20-zhong-shi-xian-miao-sha-shang-pin-jian-ku-cun.html</guid><pubDate>Sat, 06 Sep 2025 09:15:38 +0000</pubDate></item><item><title>JVM垃圾回收</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/JVM-la-ji-hui-shou.html</link><description>&lt;!-- @import '[TOC]' {cmd='toc' depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

- [JVM 垃圾回收](#jvm-垃圾回收)
  - [写在前面](#写在前面)
    - [本节常见面试题](#本节常见面试题)
    - [本文导火索](#本文导火索)
  - [1 揭开 JVM 内存分配与回收的神秘面纱](#1-揭开-jvm-内存分配与回收的神秘面纱)
    - [1.1 对象优先在 eden 区分配](#11-对象优先在-eden-区分配)
    - [1.2 大对象直接进入老年代](#12-大对象直接进入老年代)
    - [1.3 长期存活的对象将进入老年代](#13-长期存活的对象将进入老年代)
    - [1.4 动态对象年龄判定](#14-动态对象年龄判定)
    - [1.5 主要进行 gc 的区域](#15-主要进行-gc-的区域)
  - [2 对象已经死亡？](#2-对象已经死亡)
    - [2.1 引用计数法](#21-引用计数法)
    - [2.2 可达性分析算法](#22-可达性分析算法)
    - [2.3 再谈引用](#23-再谈引用)
    - [2.4 不可达的对象并非“非死不可”](#24-不可达的对象并非非死不可)
    - [2.5 如何判断一个常量是废弃常量？](#25-如何判断一个常量是废弃常量)
    - [2.6 如何判断一个类是无用的类](#26-如何判断一个类是无用的类)
  - [3 垃圾收集算法](#3-垃圾收集算法)
    - [3.1 标记-清除算法](#31-标记-清除算法)
    - [3.2 标记-复制算法](#32-标记-复制算法)
    - [3.3 标记-整理算法](#33-标记-整理算法)
    - [3.4 分代收集算法](#34-分代收集算法)
  - [4 垃圾收集器](#4-垃圾收集器)
    - [4.1 Serial 收集器](#41-serial-收集器)
    - [4.2 ParNew 收集器](#42-parnew-收集器)
    - [4.3 Parallel Scavenge 收集器](#43-parallel-scavenge-收集器)
    - [4.4.Serial Old 收集器](#44serial-old-收集器)
    - [4.5 Parallel Old 收集器](#45-parallel-old-收集器)
    - [4.6 CMS 收集器](#46-cms-收集器)
    - [4.7 G1 收集器](#47-g1-收集器)
    - [4.8 ZGC 收集器](#48-zgc-收集器)
  - [参考](#参考)

&lt;!-- /code_chunk_output --&gt;


# JVM 垃圾回收

## 写在前面

### 本节常见面试题

问题答案在文中都有提到

- 如何判断对象是否死亡（两种方法）。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/JVM-la-ji-hui-shou.html</guid><pubDate>Sat, 06 Sep 2025 09:14:32 +0000</pubDate></item><item><title>详解ThreadLocal关键字</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/xiang-jie-ThreadLocal-guan-jian-zi.html</link><description>&gt; 本文来自一枝花算不算浪漫投稿， 原文地址：[https://juejin.im/post/5eacc1c75188256d976df748](https://juejin.im/post/5eacc1c75188256d976df748)。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/xiang-jie-ThreadLocal-guan-jian-zi.html</guid><pubDate>Sat, 06 Sep 2025 09:14:00 +0000</pubDate></item><item><title>HashMap(JDK1.8)源码+底层数据结构分析</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/HashMap%28JDK1.8%29-yuan-ma-%2B-di-ceng-shu-ju-jie-gou-fen-xi.html</link><description>参考与：https://mp.weixin.qq.com/s/0Gf2DzuzgEx0i3mHVvhKNQ

&gt; ### 问：hashMap中hash冲突后，新的Entry节点在插入链表的时候，是怎么插入的么？

**java8之前是头插法**，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，因为写这个代码的作者认为**后来的值被查找的可能性更大一点，提升查找的效率。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/HashMap%28JDK1.8%29-yuan-ma-%2B-di-ceng-shu-ju-jie-gou-fen-xi.html</guid><pubDate>Sat, 06 Sep 2025 09:13:08 +0000</pubDate></item><item><title>读写分离&amp;分库分表常见问题</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/du-xie-fen-li-%26-fen-ku-fen-biao-chang-jian-wen-ti.html</link><description>读写分离主要是为了将数据库的读和写操作分不到不同的数据库节点上。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/du-xie-fen-li-%26-fen-ku-fen-biao-chang-jian-wen-ti.html</guid><pubDate>Sat, 06 Sep 2025 09:12:37 +0000</pubDate></item><item><title>Spring Cloud</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud.html</link><description>&gt; 本文基于 Spring Cloud Netflix 。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Cloud.html</guid><pubDate>Sat, 06 Sep 2025 09:11:43 +0000</pubDate></item><item><title>Kafka常见面试总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Kafka-chang-jian-mian-shi-zong-jie.html</link><description>
## Kafka面试题总结

### 一、Kafka 是什么？主要应用场景有哪些？

&gt; **如何回答：1.kafka由哪几部分组成？2.应用的场景？（异步，解耦，消峰）3.引入后产生的一列问题和注意事项？**

Kafka 是一个分布式流式处理平台。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Kafka-chang-jian-mian-shi-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:10:56 +0000</pubDate></item><item><title>Redis常见问题总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Redis-chang-jian-wen-ti-zong-jie.html</link><description>
### 参考文献：
[Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
[整理好了，Redis面试题(重要)](https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA)
[Redis常见面试题](https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ)
[Redis为什么变慢了？一文讲透如何排查Redis性能问题](https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw)
[Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？](https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g)
[缓存一致性问题怎么解决？](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)

## 一、简单介绍一下 Redis 呗!
如何回答：1.key-value结构存储的非关系型数据库；2.优点：内存存储、丰富数据结构、单线程IO、支持持久化；3.场景：分布式缓存、分布式锁、分布式队列、排行榜、查找附近的人等等；

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Redis-chang-jian-wen-ti-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:10:13 +0000</pubDate></item><item><title>Zookeeper分布式协调服务</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Zookeeper-fen-bu-shi-xie-diao-fu-wu.html</link><description>## 一、分布式的基本概念

### 1.1 系统高可用
所谓的系统高可用，主要是指两个方面：
- 系统的健壮性, 不允许系统出现单点故障；
- 系统的处理能力, 可以提高系统的处理能力, 保证系统的运行效率

**集群**
 所谓的集群, 主要是原来使用的是一台服务器处理, 现在使用多台服务器保障系统的运行，主要分为：

- **主备集群:** 主要有一个主要节点提供服务, 另外的节点主要是出于备份状态, 平时不提供工作, 一旦主节点出现问题, 备份节点启动运行, 提供正常的服务；

![QQ图片20211005131557.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131557-63e5f8b0303f4921a8ddc066f5491de4.png)

- **主从集群:** 集群中的节点都提供服务, 但是每台服务器的角色可能不一样, 比如配置数据库的读写分离, 主数据库可能是写操作, 对于实时性要求不高的读操作就使用从数据库，该模式对于主从有数据传输延迟性；

![QQ图片20211005131606.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131606-2462413ea43e4b3195c95989cd2e1f96.png)

- **普通集群:** 集群中的节点提供的功能是一样的, 所有的节点没有主从之分,主要是提高系统的高可用；

![QQ图片20211005131608.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005131608-fd7c58a463614a1dbb26b212de33740c.png)

**分布式**

分布式是系统部署方式：
- 比如我们的业务系统, 部署一个业务系统需要的环境(应用服务(Tomcat)+数据库服务(MySQL))；

- 如果我们把Tomcat和数据库MySQL服务部署在同一台服务器, 我们称之为单机部署, 这样Tomcat和MySQL之间的网络开销可以忽略(直接走127.0.0.1不会消耗网络)；

- 如果我们把Tomcat和数据库MySQL服务部署在不同的服务器, 我们称之为分布式应用, 因为应用服务器和数据库服务器之间需要走网络通信, 当然, **我们把所有需要走网络这种部署方式称之为'分布式应用'**；

![QQ图片20211005132216.png](/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211005132216-e8540e32c1da481899ca7203721bf30b.png)

**微服务**
当使用单体应用时：其中一个模块挂了，整个系统（crm）都会访问不了；如果只是针对整个jar包（crm.jar）部署的话，就没法针对高并发模块进行单独的增强扩容或者添加服务器了；对于系统维护/后期开发不方便，若想要单独操作一个模块，需要把整个系统停掉，导致其他模块不可用。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Zookeeper-fen-bu-shi-xie-diao-fu-wu.html</guid><pubDate>Sat, 06 Sep 2025 09:08:15 +0000</pubDate></item><item><title>SpringBoot项目汇总</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-xiang-mu-hui-zong.html</link><description>## 一、项目简述

### 企业开发中常见的后台管理系统？

**CRM（客户关系管理）：**  管理客户信息，如个人信息、订单信息等；

![QQ图片20210928140559.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140559-5ded626505dc4242a5e30a8f297b9d87.png)

**OA（办公自动化）：** 基于工作流概念，使企业内部人员方便快捷地共享信息，高效协同工作；

![QQ图片20210928140611.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140611-b584b2a7e9c343e3b5feb97319cc1604.png)

**ERP（企业资源计划）：** 物资资源管理、人力资源管理、财务资源管理、信息资源管理等集成一体化；

![QQ图片20210928140615.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210928140615-e3a4ef17394348d5b4509566c6f7d8a9.png)

### 基础构建

**1. pom.xml依赖：** Spring单元测试、数据库、AOP、后端校验、接口文档Springfox、对象转换、验证码、缓存、权限控制Shiro等等。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-xiang-mu-hui-zong.html</guid><pubDate>Sat, 06 Sep 2025 09:07:16 +0000</pubDate></item><item><title>SpringBoot的自动装配原理</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-de-zi-dong-zhuang-pei-yuan-li.html</link><description>## 前言

我觉得我们可以从以下几个方面回答：
1. 什么是 SpringBoot 自动装配？
2. SpringBoot 是如何实现自动装配的？如何实现按需加载？
3. 如何实现一个 Starter？

使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-de-zi-dong-zhuang-pei-yuan-li.html</guid><pubDate>Sat, 06 Sep 2025 09:06:40 +0000</pubDate></item><item><title>SpringBoot实现拦截器Interceptor</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-shi-xian-lan-jie-qi-Interceptor.html</link><description>&gt; 本文大部分内容是对国外一个不错的文章 ：https://o7planning.org/en/11689/spring-boot-interceptors-tutorial 的翻译，做了适当的修改。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/SpringBoot-shi-xian-lan-jie-qi-Interceptor.html</guid><pubDate>Sat, 06 Sep 2025 09:05:49 +0000</pubDate></item><item><title>Spring Boot</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Boot.html</link><description>## **SpingBoot - Maven补充**

### **一、依赖冲突**

![QQ图片20210925161432.png](/upload/2021/09/QQ%E5%9B%BE%E7%89%8720210925161432-2bd4801c2b3f4e1992be661f96a0027c.png)

**如何解决依赖冲突？**

&gt; 方法一：默认情况下：优先保留前面先声明的版本，所以就算出现的依赖冲突但整个项目运行中是不会报错的，Maven已经自动处理好了！

&gt; 方法二：单独为依赖库增加`dependency`指定版本号，就如依赖冲突例子可得，可以直接在dependencies中添加spring-beans的版本！

&gt; 方法三：使用`exclusion`排除某个依赖，比如在添加spring-webmvc依赖时，使用属性标签`exclusion`排除`spring-beans`，这样`spring-beans`版本只能选择`spring-jdbc`的版本了！

&gt; 方法四(最常用的解决方案)：使用`dependencyManagement`锁定依赖库的版本号，注意该方法只能声明版本号，不能真正下载导入依赖库！


### **二、分模块构建项目**
项目规模比较庞大时，可以考虑对项目进行拆分，分模块进行构建项目，有2种常见的拆分思路：按业务模块：员工模块、部门模块、工资模块等；按层：dao层、service层、web层等。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20Boot.html</guid><pubDate>Sat, 06 Sep 2025 09:05:08 +0000</pubDate></item><item><title>Spring 框架设计模式</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20-kuang-jia-she-ji-mo-shi.html</link><description>&lt;!-- TOC --&gt;

- [控制反转(IoC)和依赖注入(DI)](#控制反转ioc和依赖注入di)
- [工厂设计模式](#工厂设计模式)
- [单例设计模式](#单例设计模式)
- [代理设计模式](#代理设计模式)
    - [代理模式在 AOP 中的应用](#代理模式在-aop-中的应用)
    - [Spring AOP 和 AspectJ AOP 有什么区别?](#spring-aop-和-aspectj-aop-有什么区别)
- [模板方法](#模板方法)
- [观察者模式](#观察者模式)
    - [Spring 事件驱动模型中的三种角色](#spring-事件驱动模型中的三种角色)
        - [事件角色](#事件角色)
        - [事件监听者角色](#事件监听者角色)
        - [事件发布者角色](#事件发布者角色)
    - [Spring 的事件流程总结](#spring-的事件流程总结)
- [适配器模式](#适配器模式)
    - [spring AOP中的适配器模式](#spring-aop中的适配器模式)
    - [spring MVC中的适配器模式](#spring-mvc中的适配器模式)
- [装饰者模式](#装饰者模式)
- [总结](#总结)
- [参考](#参考)

&lt;!-- /TOC --&gt;

### 参考文献：[设计模式目录](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)

## **Spring 框架中用到了哪些设计模式？**

关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章[《面试官:“谈谈 Spring 中都用到了那些设计模式?”。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20-kuang-jia-she-ji-mo-shi.html</guid><pubDate>Sat, 06 Sep 2025 09:04:36 +0000</pubDate></item><item><title>Spring</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring.html</link><description>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！

下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring.html</guid><pubDate>Sat, 06 Sep 2025 09:03:49 +0000</pubDate></item><item><title>MySQL数据库索引</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-shu-ju-ku-suo-yin.html</link><description>## 一、何为索引？有什么作用？**

**索引是一种用于快速查询和检索数据的数据结构。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-shu-ju-ku-suo-yin.html</guid><pubDate>Sat, 06 Sep 2025 09:02:56 +0000</pubDate></item><item><title>并发进阶总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/bing-fa-jin-jie-zong-jie.html</link><description>&lt;!-- @import '[TOC]' {cmd='toc' depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

- [Java 并发进阶常见面试题总结](#java-并发进阶常见面试题总结)
  - [1.synchronized 关键字](#1synchronized-关键字)
    - [1.1.说一说自己对于 synchronized 关键字的了解](#11说一说自己对于-synchronized-关键字的了解)
    - [1.2. 说说自己是怎么使用 synchronized 关键字](#12-说说自己是怎么使用-synchronized-关键字)
    - [1.3. 构造方法可以使用 synchronized 关键字修饰么？](#13-构造方法可以使用-synchronized-关键字修饰么)
    - [1.3. 讲一下 synchronized 关键字的底层原理](#13-讲一下-synchronized-关键字的底层原理)
      - [1.3.1. synchronized 同步语句块的情况](#131-synchronized-同步语句块的情况)
      - [1.3.2. synchronized 修饰方法的的情况](#132-synchronized-修饰方法的的情况)
      - [1.3.3.总结](#133总结)
    - [1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗](#14-说说-jdk16-之后的-synchronized-关键字底层做了哪些优化可以详细介绍一下这些优化吗)
    - [1.5. 谈谈 synchronized 和 ReentrantLock 的区别](#15-谈谈-synchronized-和-reentrantlock-的区别)
      - [1.5.1. 两者都是可重入锁](#151-两者都是可重入锁)
      - [1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API](#152synchronized-依赖于-jvm-而-reentrantlock-依赖于-api)
      - [1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能](#153reentrantlock-比-synchronized-增加了一些高级功能)
  - [2. volatile 关键字](#2-volatile-关键字)
    - [2.1. CPU 缓存模型](#21-cpu-缓存模型)
    - [2.2. 讲一下 JMM(Java 内存模型)](#22-讲一下-jmmjava-内存模型)
    - [2.3. 并发编程的三个重要特性](#23-并发编程的三个重要特性)
    - [2.4. 说说 synchronized 关键字和 volatile 关键字的区别](#24-说说-synchronized-关键字和-volatile-关键字的区别)
  - [3. ThreadLocal](#3-threadlocal)
    - [3.1. ThreadLocal 简介](#31-threadlocal-简介)
    - [3.2. ThreadLocal 示例](#32-threadlocal-示例)
    - [3.3. ThreadLocal 原理](#33-threadlocal-原理)
    - [3.4. ThreadLocal 内存泄露问题](#34-threadlocal-内存泄露问题)
  - [4. 线程池](#4-线程池)
    - [4.1. 为什么要用线程池？](#41-为什么要用线程池)
    - [4.2. 实现 Runnable 接口和 Callable 接口的区别](#42-实现-runnable-接口和-callable-接口的区别)
    - [4.3. 执行 execute()方法和 submit()方法的区别是什么呢？](#43-执行-execute方法和-submit方法的区别是什么呢)
    - [4.4. 如何创建线程池](#44-如何创建线程池)
    - [4.5 ThreadPoolExecutor 类分析](#45-threadpoolexecutor-类分析)
      - [4.5.1 `ThreadPoolExecutor`构造函数重要参数分析](#451-threadpoolexecutor构造函数重要参数分析)
      - [4.5.2 `ThreadPoolExecutor` 饱和策略](#452-threadpoolexecutor-饱和策略)
    - [4.6 一个简单的线程池 Demo](#46-一个简单的线程池-demo)
    - [4.7 线程池原理分析](#47-线程池原理分析)
  - [5. Atomic 原子类](#5-atomic-原子类)
    - [5.1. 介绍一下 Atomic 原子类](#51-介绍一下-atomic-原子类)
    - [5.2. JUC 包中的原子类是哪 4 类?](#52-juc-包中的原子类是哪-4-类)
    - [5.3. 讲讲 AtomicInteger 的使用](#53-讲讲-atomicinteger-的使用)
    - [5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理](#54-能不能给我简单介绍一下-atomicinteger-类的原理)
  - [6. AQS](#6-aqs)
    - [6.1. AQS 介绍](#61-aqs-介绍)
    - [6.2. AQS 原理分析](#62-aqs-原理分析)
      - [6.2.1. AQS 原理概览](#621-aqs-原理概览)
      - [6.2.2. AQS 对资源的共享方式](#622-aqs-对资源的共享方式)
      - [6.2.3. AQS 底层使用了模板方法模式](#623-aqs-底层使用了模板方法模式)
    - [6.3. AQS 组件总结](#63-aqs-组件总结)
    - [6.4. 用过 CountDownLatch 么？什么场景下用的？](#64-用过-countdownlatch-么什么场景下用的)
  - [7 Reference](#7-reference)

&lt;!-- /code_chunk_output --&gt;


# **Java 并发进阶常见面试题总结**

## **1.synchronized 关键字**

![synchronized关键字.png](/upload/2021/10/synchronized%E5%85%B3%E9%94%AE%E5%AD%97-bf5a1263796649aba1b54cc9201a40a6.png)

&gt; ### 问：知道synchronized原理吗？

synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/bing-fa-jin-jie-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:02:26 +0000</pubDate></item><item><title>Java并发基础总结</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-bing-fa-ji-chu-zong-jie.html</link><description>&lt;!-- TOC --&gt;

- [Java 并发基础常见面试题总结](#Java-并发基础常见面试题总结)
  - [1. 什么是线程和进程?](#1-什么是线程和进程)
    - [1.1. 何为进程?](#11-何为进程)
    - [1.2. 何为线程?](#12-何为线程)
  - [2. 请简要描述线程与进程的关系,区别及优缺点？](#2-请简要描述线程与进程的关系区别及优缺点)
    - [2.1. 图解进程和线程的关系](#21-图解进程和线程的关系)
    - [2.2. 程序计数器为什么是私有的?](#22-程序计数器为什么是私有的)
    - [2.3. 虚拟机栈和本地方法栈为什么是私有的?](#23-虚拟机栈和本地方法栈为什么是私有的)
    - [2.4. 一句话简单了解堆和方法区](#24-一句话简单了解堆和方法区)
  - [3. 说说并发与并行的区别?](#3-说说并发与并行的区别)
  - [4. 为什么要使用多线程呢?](#4-为什么要使用多线程呢)
  - [5. 使用多线程可能带来什么问题?](#5-使用多线程可能带来什么问题)
  - [6. 说说线程的生命周期和状态?](#6-说说线程的生命周期和状态)
  - [7. 什么是上下文切换?](#7-什么是上下文切换)
  - [8. 什么是线程死锁?如何避免死锁?](#8-什么是线程死锁如何避免死锁)
    - [8.1. 认识线程死锁](#81-认识线程死锁)
    - [8.2. 如何避免线程死锁?](#82-如何避免线程死锁)
  - [9. 说说 sleep() 方法和 wait() 方法区别和共同点?](#9-说说-sleep-方法和-wait-方法区别和共同点)
  - [10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？](#10-为什么我们调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法)
  - [公众号](#公众号)

&lt;!-- /TOC --&gt;

# Java 并发基础常见面试题总结

### 参考文献：[Java 并发](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md)

## 1. 什么是线程和进程?

### 1.1. 何为进程?

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-bing-fa-ji-chu-zong-jie.html</guid><pubDate>Sat, 06 Sep 2025 09:01:45 +0000</pubDate></item><item><title>MyBatis基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MyBatis-ji-chu.html</link><description>## **基本使用**
#### **1.企业的流行框架**
SSM：Spring、SpringMVC、MyBatis
Apache Shiro
SpingBoot

#### **2.客户端请求流程**
- 客户端请求会先来到 `控制层Servlet/Controller`，再到 `业务层Service`，最后为 `数据持久层Dao`。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MyBatis-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 09:01:05 +0000</pubDate></item><item><title>MySQL的三大日志</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-de-san-da-ri-zhi.html</link><description>## **前言**

### 参考文档：[原来MySQL面试还会问这些...](https://mp.weixin.qq.com/s/Lx4TNPLQzYaknR7D3gmOmQ)

`MySQL日志` 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-de-san-da-ri-zhi.html</guid><pubDate>Sat, 06 Sep 2025 08:59:48 +0000</pubDate></item><item><title>MySQL优化规范</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-you-hua-gui-fan.html</link><description>&lt;!-- TOC --&gt;

- [数据库命令规范](#数据库命令规范)
- [数据库基本设计规范](#数据库基本设计规范)
    - [1. 所有表必须使用 Innodb 存储引擎](#1-所有表必须使用-innodb-存储引擎)
    - [2. 数据库和表的字符集统一使用 UTF8](#2-数据库和表的字符集统一使用-utf8)
    - [3. 所有表和字段都需要添加注释](#3-所有表和字段都需要添加注释)
    - [4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/MySQL-you-hua-gui-fan.html</guid><pubDate>Sat, 06 Sep 2025 08:58:57 +0000</pubDate></item><item><title>数据库知识概述</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/shu-ju-ku-zhi-shi-gai-shu.html</link><description>### 参考文献：[MySQL](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)、[SQL 练习](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md)、[SQL 语法](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md)

### **一、什么是数据库,数据库管理系统,数据库系统,数据库管理员?**

- **数据库** :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/shu-ju-ku-zhi-shi-gai-shu.html</guid><pubDate>Sat, 06 Sep 2025 08:58:05 +0000</pubDate></item><item><title>计算机网络基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/ji-suan-ji-wang-luo-ji-chu.html</link><description>### 参考文献：[HTTP](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md) ------ http方法、状态码、首部、https、http1.0/2.0；  

## 一 OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/ji-suan-ji-wang-luo-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 08:56:37 +0000</pubDate></item><item><title>Liunx基础操作</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Liunx-ji-chu-cao-zuo.html</link><description>### 参考文献：[Linux](https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md)

今天这篇文章中简单介绍一下一个 Java 程序员必知的 Linux 的一些概念以及常见命令。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Liunx-ji-chu-cao-zuo.html</guid><pubDate>Sat, 06 Sep 2025 08:55:57 +0000</pubDate></item><item><title>操作系统基础</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/cao-zuo-xi-tong-ji-chu.html</link><description>### 参考文献：[计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md)

大家好，我是帅哥！

这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/cao-zuo-xi-tong-ji-chu.html</guid><pubDate>Sat, 06 Sep 2025 08:54:40 +0000</pubDate></item><item><title>垃圾回收机制</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/la-ji-hui-shou-ji-zhi.html</link><description>## 前言
Java 相比 C/C++ 最显著的特点便是**引入了自动垃圾回收** (下文统一用 GC 指代自动垃圾回收)，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/la-ji-hui-shou-ji-zhi.html</guid><pubDate>Sat, 06 Sep 2025 08:53:10 +0000</pubDate></item><item><title>Java中那18 把锁</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-na-18%20-ba-suo.html</link><description>### [互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://mp.weixin.qq.com/s/6QrQ0TZVqSQq26Rms0_mvA)

## 一、乐观锁和悲观锁

### 1. 悲观锁

悲观锁对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/Java-zhong-na-18%20-ba-suo.html</guid><pubDate>Sat, 06 Sep 2025 08:49:24 +0000</pubDate></item><item><title>RAG</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/RAG.html</link><description># 大模型知识问答RAG

## 一、RAG

&gt; **RAG主要涉及企业内部的文档数据，如果需要一些插件功能，只能需要外部Function calling调用等操作；**

大模型缺点：知识不是实时的、不知道私有领域的业务知识。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/RAG.html</guid><pubDate>Wed, 18 Jun 2025 10:57:45 +0000</pubDate></item><item><title>第一篇博客</title><link>https://shuaiwang888.github.io/appStore-Blog.github.io/post/di-yi-pian-bo-ke.html</link><description>## 第一

### 第二

- ![Image](https://github.com/user-attachments/assets/49178100-4fd3-41c1-8f76-15531692576e)

Retrieval-Augmented Generation（RAG） 将“检索”与“生成”结合，保障回答的 **事实准确性** 与 **自然表达**。</description><guid isPermaLink="true">https://shuaiwang888.github.io/appStore-Blog.github.io/post/di-yi-pian-bo-ke.html</guid><pubDate>Wed, 18 Jun 2025 10:54:31 +0000</pubDate></item></channel></rss>