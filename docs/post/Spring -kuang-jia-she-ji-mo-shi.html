<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="<!-- TOC -->

- [控制反转(IoC)和依赖注入(DI)](#控制反转ioc和依赖注入di)
- [工厂设计模式](#工厂设计模式)
- [单例设计模式](#单例设计模式)
- [代理设计模式](#代理设计模式)
    - [代理模式在 AOP 中的应用](#代理模式在-aop-中的应用)
    - [Spring AOP 和 AspectJ AOP 有什么区别?](#spring-aop-和-aspectj-aop-有什么区别)
- [模板方法](#模板方法)
- [观察者模式](#观察者模式)
    - [Spring 事件驱动模型中的三种角色](#spring-事件驱动模型中的三种角色)
        - [事件角色](#事件角色)
        - [事件监听者角色](#事件监听者角色)
        - [事件发布者角色](#事件发布者角色)
    - [Spring 的事件流程总结](#spring-的事件流程总结)
- [适配器模式](#适配器模式)
    - [spring AOP中的适配器模式](#spring-aop中的适配器模式)
    - [spring MVC中的适配器模式](#spring-mvc中的适配器模式)
- [装饰者模式](#装饰者模式)
- [总结](#总结)
- [参考](#参考)

<!-- /TOC -->

### 参考文献：[设计模式目录](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)

## **Spring 框架中用到了哪些设计模式？**

关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章[《面试官:“谈谈 Spring 中都用到了那些设计模式?”。">
<meta property="og:title" content="Spring 框架设计模式">
<meta property="og:description" content="<!-- TOC -->

- [控制反转(IoC)和依赖注入(DI)](#控制反转ioc和依赖注入di)
- [工厂设计模式](#工厂设计模式)
- [单例设计模式](#单例设计模式)
- [代理设计模式](#代理设计模式)
    - [代理模式在 AOP 中的应用](#代理模式在-aop-中的应用)
    - [Spring AOP 和 AspectJ AOP 有什么区别?](#spring-aop-和-aspectj-aop-有什么区别)
- [模板方法](#模板方法)
- [观察者模式](#观察者模式)
    - [Spring 事件驱动模型中的三种角色](#spring-事件驱动模型中的三种角色)
        - [事件角色](#事件角色)
        - [事件监听者角色](#事件监听者角色)
        - [事件发布者角色](#事件发布者角色)
    - [Spring 的事件流程总结](#spring-的事件流程总结)
- [适配器模式](#适配器模式)
    - [spring AOP中的适配器模式](#spring-aop中的适配器模式)
    - [spring MVC中的适配器模式](#spring-mvc中的适配器模式)
- [装饰者模式](#装饰者模式)
- [总结](#总结)
- [参考](#参考)

<!-- /TOC -->

### 参考文献：[设计模式目录](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)

## **Spring 框架中用到了哪些设计模式？**

关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章[《面试官:“谈谈 Spring 中都用到了那些设计模式?”。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shuaiwang888.github.io/appStore-Blog.github.io/post/Spring%20-kuang-jia-she-ji-mo-shi.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>Spring 框架设计模式</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Spring 框架设计模式</h1>
<div class="title-right">
    <a href="https://shuaiwang888.github.io/appStore-Blog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shuaiwang888/appStore-Blog.github.io/issues/18" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody">
<ul>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di">控制反转(IoC)和依赖注入(DI)</a></li>
<li><a href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">工厂设计模式</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">单例设计模式</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">代理设计模式</a>
<ul>
<li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9C%A8-aop-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">代理模式在 AOP 中的应用</a></li>
<li><a href="#spring-aop-%E5%92%8C-aspectj-aop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Spring AOP 和 AspectJ AOP 有什么区别?</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">模板方法</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a>
<ul>
<li><a href="#spring-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2">Spring 事件驱动模型中的三种角色</a>
<ul>
<li><a href="#%E4%BA%8B%E4%BB%B6%E8%A7%92%E8%89%B2">事件角色</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%80%85%E8%A7%92%E8%89%B2">事件监听者角色</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%80%85%E8%A7%92%E8%89%B2">事件发布者角色</a></li>
</ul>
</li>
<li><a href="#spring-%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93">Spring 的事件流程总结</a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a>
<ul>
<li><a href="#spring-aop%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">spring AOP中的适配器模式</a></li>
<li><a href="#spring-mvc%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">spring MVC中的适配器模式</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>

<h3>参考文献：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md">设计模式目录</a></h3>
<h2><strong>Spring 框架中用到了哪些设计模式？</strong></h2>
<p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd" rel="nofollow">《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code class="notranslate">BeanFactory</code>、<code class="notranslate">ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code class="notranslate">jdbcTemplate</code>、<code class="notranslate">hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code class="notranslate">Controller</code>。</li>
<li>......</li>
</ul>
<p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。</p>
<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<h2><strong>控制反转(IoC)和依赖注入(DI)</strong></h2>
<p><strong>IoC(Inversion of Control,控制反转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/92e6f17f500f63a340b52ef769384a924eff1bc414b16f5f2a663f38326c11e0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f696f632d7061747465726e732e706e67"><img src="https://camo.githubusercontent.com/92e6f17f500f63a340b52ef769384a924eff1bc414b16f5f2a663f38326c11e0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f696f632d7061747465726e732e706e67" alt="ioc-patterns" style="max-width: 100%;"></a></p>
<p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a href="https://www.zhihu.com/question/23277575/answer/169698662" rel="nofollow">https://www.zhihu.com/question/23277575/answer/169698662</a>  ，非常不错。</p>
<p><strong>控制反转怎么理解呢?</strong> 举个例子："对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中"。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h2><strong>工厂设计模式</strong></h2>
<p>Spring使用工厂模式可以通过 <code class="notranslate">BeanFactory</code> 或 <code class="notranslate">ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code class="notranslate">BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code class="notranslate">ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code class="notranslate">ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code class="notranslate">BeanFactory</code> 仅提供了最基本的依赖注入支持，<code class="notranslate"> ApplicationContext</code> 扩展了 <code class="notranslate">BeanFactory</code> ,除了有<code class="notranslate">BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code class="notranslate"> ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code class="notranslate">ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code class="notranslate">FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code class="notranslate">XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">org</span>.<span class="pl-s1">springframework</span>.<span class="pl-s1">context</span>.<span class="pl-s1">ApplicationContext</span>;
<span class="pl-k">import</span> <span class="pl-s1">org</span>.<span class="pl-s1">springframework</span>.<span class="pl-s1">context</span>.<span class="pl-s1">support</span>.<span class="pl-s1">FileSystemXmlApplicationContext</span>;
 
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">App</span> {
	<span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span>[] <span class="pl-s1">args</span>) {
		<span class="pl-smi">ApplicationContext</span> <span class="pl-s1">context</span> = <span class="pl-k">new</span> <span class="pl-smi">FileSystemXmlApplicationContext</span>(
				<span class="pl-s">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);
 
		<span class="pl-smi">HelloApplicationContext</span> <span class="pl-s1">obj</span> = (<span class="pl-smi">HelloApplicationContext</span>) <span class="pl-s1">context</span>.<span class="pl-en">getBean</span>(<span class="pl-s">"helloApplicationContext"</span>);
		<span class="pl-s1">obj</span>.<span class="pl-en">getMsg</span>();
	}
}</pre></div>
<h2><strong>单例设计模式</strong></h2>
<p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml : <code class="notranslate">&lt;bean id="userService" class="top.snailclimb.UserService" scope="singleton"/&gt;</code></li>
<li>注解：<code class="notranslate">@Scope(value = "singleton")</code></li>
</ul>
<p><strong>Spring 通过 <code class="notranslate">ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span>
<span class="pl-k">private</span> <span class="pl-k">final</span> <span class="pl-smi">Map</span>&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt; <span class="pl-s1">singletonObjects</span> = <span class="pl-k">new</span> <span class="pl-smi">ConcurrentHashMap</span>&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;(<span class="pl-c1">64</span>);

<span class="pl-k">public</span> <span class="pl-smi">Object</span> <span class="pl-en">getSingleton</span>(<span class="pl-smi">String</span> <span class="pl-s1">beanName</span>, <span class="pl-smi">ObjectFactory</span>&lt;?&gt; <span class="pl-s1">singletonFactory</span>) {
        <span class="pl-smi">Assert</span>.<span class="pl-en">notNull</span>(<span class="pl-s1">beanName</span>, <span class="pl-s">"'beanName' must not be null"</span>);
        <span class="pl-k">synchronized</span> (<span class="pl-smi">this</span>.<span class="pl-s1">singletonObjects</span>) {
            <span class="pl-c">// 检查缓存中是否存在实例  </span>
            <span class="pl-smi">Object</span> <span class="pl-s1">singletonObject</span> = <span class="pl-smi">this</span>.<span class="pl-s1">singletonObjects</span>.<span class="pl-en">get</span>(<span class="pl-s1">beanName</span>);
            <span class="pl-k">if</span> (<span class="pl-s1">singletonObject</span> == <span class="pl-c1">null</span>) {
                <span class="pl-c">//...省略了很多代码</span>
                <span class="pl-k">try</span> {
                    <span class="pl-s1">singletonObject</span> = <span class="pl-s1">singletonFactory</span>.<span class="pl-en">getObject</span>();
                }
                <span class="pl-c">//...省略了很多代码</span>
                <span class="pl-c">// 如果实例对象在不存在，我们注册到单例注册表中。</span>
                <span class="pl-en">addSingleton</span>(<span class="pl-s1">beanName</span>, <span class="pl-s1">singletonObject</span>);
            }
            <span class="pl-k">return</span> (<span class="pl-s1">singletonObject</span> != <span class="pl-c1">NULL_OBJECT</span> ? <span class="pl-s1">singletonObject</span> : <span class="pl-c1">null</span>);
        }
    }
    <span class="pl-c">//将对象添加到单例注册表</span>
    <span class="pl-k">protected</span> <span class="pl-smi">void</span> <span class="pl-en">addSingleton</span>(<span class="pl-smi">String</span> <span class="pl-s1">beanName</span>, <span class="pl-smi">Object</span> <span class="pl-s1">singletonObject</span>) {
            <span class="pl-k">synchronized</span> (<span class="pl-smi">this</span>.<span class="pl-s1">singletonObjects</span>) {
                <span class="pl-smi">this</span>.<span class="pl-s1">singletonObjects</span>.<span class="pl-en">put</span>(<span class="pl-s1">beanName</span>, (<span class="pl-s1">singletonObject</span> != <span class="pl-c1">null</span> ? <span class="pl-s1">singletonObject</span> : <span class="pl-c1">NULL_OBJECT</span>));

            }
        }
}</pre></div>
<h2><strong>代理设计模式</strong></h2>
<h3><strong>代理模式在 AOP 中的应用</strong></h3>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/274ad95cb0033b413fa4b975b5ff2f2bed0480f4ac8cf70d44b3fc628999728e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e67414f5050726f636573732e6a7067"><img src="https://camo.githubusercontent.com/274ad95cb0033b413fa4b975b5ff2f2bed0480f4ac8cf70d44b3fc628999728e/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e67414f5050726f636573732e6a7067" alt="SpringAOPProcess" data-canonical-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" style="max-width: 100%;"></a></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3>Spring AOP 和 AspectJ AOP 有什么区别?</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2><strong>模板方法</strong></h2>
<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-smi">Template</span> {
    <span class="pl-c">//这是我们的模板方法</span>
    <span class="pl-k">public</span> <span class="pl-k">final</span> <span class="pl-smi">void</span> <span class="pl-en">TemplateMethod</span>(){
        <span class="pl-en">PrimitiveOperation1</span>();  
        <span class="pl-en">PrimitiveOperation2</span>();
        <span class="pl-en">PrimitiveOperation3</span>();
    }

    <span class="pl-k">protected</span> <span class="pl-smi">void</span>  <span class="pl-en">PrimitiveOperation1</span>(){
        <span class="pl-c">//当前类实现</span>
    }
    
    <span class="pl-c">//被子类实现的方法</span>
    <span class="pl-k">protected</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">PrimitiveOperation2</span>();
    <span class="pl-k">protected</span> <span class="pl-k">abstract</span> <span class="pl-smi">void</span> <span class="pl-en">PrimitiveOperation3</span>();

}
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">TemplateImpl</span> <span class="pl-k">extends</span> <span class="pl-smi">Template</span> {

    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">PrimitiveOperation2</span>() {
        <span class="pl-c">//当前类实现</span>
    }
    
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">PrimitiveOperation3</span>() {
        <span class="pl-c">//当前类实现</span>
    }
}</pre></div>
<p>Spring 中 <code class="notranslate">jdbcTemplate</code>、<code class="notranslate">hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2><strong>观察者模式</strong></h2>
<p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3><strong>Spring 事件驱动模型中的三种角色</strong></h3>
<h4><strong>事件角色</strong></h4>
<p><code class="notranslate">ApplicationEvent</code> (<code class="notranslate">org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code class="notranslate">java.util.EventObject</code>并实现了 <code class="notranslate">java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code class="notranslate">ApplicationContextEvent</code> 的实现(继承自<code class="notranslate">ApplicationContextEvent</code>)：</p>
<ul>
<li><code class="notranslate">ContextStartedEvent</code>：<code class="notranslate">ApplicationContext</code> 启动后触发的事件;</li>
<li><code class="notranslate">ContextStoppedEvent</code>：<code class="notranslate">ApplicationContext</code> 停止后触发的事件;</li>
<li><code class="notranslate">ContextRefreshedEvent</code>：<code class="notranslate">ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code class="notranslate">ContextClosedEvent</code>：<code class="notranslate">ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/543a1412668f6f1747ac9086f8ce5db421b47b2713836afbcd95b2cf2b5dda75/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4170706c69636174696f6e4576656e742d537562636c6173732e706e67"><img src="https://camo.githubusercontent.com/543a1412668f6f1747ac9086f8ce5db421b47b2713836afbcd95b2cf2b5dda75/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4170706c69636174696f6e4576656e742d537562636c6173732e706e67" alt="ApplicationEvent-Subclass" data-canonical-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ApplicationEvent-Subclass.png" style="max-width: 100%;"></a></p>
<h4><strong>事件监听者角色</strong></h4>
<p><code class="notranslate">ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code class="notranslate">onApplicationEvent（）</code>方法来处理<code class="notranslate">ApplicationEvent</code>。<code class="notranslate">ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code class="notranslate">ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code class="notranslate">ApplicationListener</code> 接口的 <code class="notranslate">onApplicationEvent()</code> 方法即可完成监听事件</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">package</span> <span class="pl-s1">org</span>.<span class="pl-s1">springframework</span>.<span class="pl-s1">context</span>;
<span class="pl-k">import</span> <span class="pl-s1">java</span>.<span class="pl-s1">util</span>.<span class="pl-s1">EventListener</span>;
<span class="pl-c1">@</span><span class="pl-c1">FunctionalInterface</span>
<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">ApplicationListener</span>&lt;<span class="pl-smi">E</span> <span class="pl-k">extends</span> <span class="pl-smi">ApplicationEvent</span>&gt; <span class="pl-k">extends</span> <span class="pl-smi">EventListener</span> {
    <span class="pl-smi">void</span> <span class="pl-en">onApplicationEvent</span>(<span class="pl-smi">E</span> <span class="pl-s1">var1</span>);
}</pre></div>
<h4><strong>事件发布者角色</strong></h4>
<p><code class="notranslate">ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c1">@</span><span class="pl-c1">FunctionalInterface</span>
<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-smi">ApplicationEventPublisher</span> {
    <span class="pl-k">default</span> <span class="pl-smi">void</span> <span class="pl-en">publishEvent</span>(<span class="pl-smi">ApplicationEvent</span> <span class="pl-s1">event</span>) {
        <span class="pl-smi">this</span>.<span class="pl-en">publishEvent</span>((<span class="pl-smi">Object</span>)<span class="pl-s1">event</span>);
    }

    <span class="pl-smi">void</span> <span class="pl-en">publishEvent</span>(<span class="pl-smi">Object</span> <span class="pl-s1">var1</span>);
}</pre></div>
<p><code class="notranslate">ApplicationEventPublisher</code> 接口的<code class="notranslate">publishEvent（）</code>这个方法在<code class="notranslate">AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code class="notranslate">ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>
<h3><strong>Spring 的事件流程总结</strong></h3>
<ol>
<li>定义一个事件: 实现一个继承自 <code class="notranslate">ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code class="notranslate">ApplicationListener</code> 接口，重写 <code class="notranslate">onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息:  可以通过 <code class="notranslate">ApplicationEventPublisher  </code> 的 <code class="notranslate">publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-c">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DemoEvent</span> <span class="pl-k">extends</span> <span class="pl-smi">ApplicationEvent</span>{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">long</span> <span class="pl-s1">serialVersionUID</span> = <span class="pl-c1">1L</span>;

    <span class="pl-k">private</span> <span class="pl-smi">String</span> <span class="pl-s1">message</span>;

    <span class="pl-k">public</span> <span class="pl-smi">DemoEvent</span>(<span class="pl-smi">Object</span> <span class="pl-s1">source</span>,<span class="pl-smi">String</span> <span class="pl-s1">message</span>){
        <span class="pl-en">super</span>(<span class="pl-s1">source</span>);
        <span class="pl-smi">this</span>.<span class="pl-s1">message</span> = <span class="pl-s1">message</span>;
    }

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getMessage</span>() {
         <span class="pl-k">return</span> <span class="pl-s1">message</span>;
          }

    
<span class="pl-c">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span>
<span class="pl-c1">@</span><span class="pl-c1">Component</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DemoListener</span> <span class="pl-k">implements</span> <span class="pl-smi">ApplicationListener</span>&lt;<span class="pl-smi">DemoEvent</span>&gt;{

    <span class="pl-c">//使用onApplicationEvent接收消息</span>
    <span class="pl-c1">@</span><span class="pl-c1">Override</span>
    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">onApplicationEvent</span>(<span class="pl-smi">DemoEvent</span> <span class="pl-s1">event</span>) {
        <span class="pl-smi">String</span> <span class="pl-s1">msg</span> = <span class="pl-s1">event</span>.<span class="pl-en">getMessage</span>();
        <span class="pl-smi">System</span>.<span class="pl-s1">out</span>.<span class="pl-en">println</span>(<span class="pl-s">"接收到的信息是："</span>+<span class="pl-s1">msg</span>);
    }

}
<span class="pl-c">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span>
<span class="pl-c1">@</span><span class="pl-c1">Component</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-smi">DemoPublisher</span> {

    <span class="pl-c1">@</span><span class="pl-c1">Autowired</span>
    <span class="pl-smi">ApplicationContext</span> <span class="pl-s1">applicationContext</span>;

    <span class="pl-k">public</span> <span class="pl-smi">void</span> <span class="pl-en">publish</span>(<span class="pl-smi">String</span> <span class="pl-s1">message</span>){
        <span class="pl-c">//发布事件</span>
        <span class="pl-s1">applicationContext</span>.<span class="pl-en">publishEvent</span>(<span class="pl-k">new</span> <span class="pl-smi">DemoEvent</span>(<span class="pl-smi">this</span>, <span class="pl-s1">message</span>));
    }
}</pre></div>
<p>当调用 <code class="notranslate">DemoPublisher </code> 的 <code class="notranslate">publish()</code> 方法的时候，比如 <code class="notranslate">demoPublisher.publish("你好")</code> ，控制台就会打印出:<code class="notranslate">接收到的信息是：你好</code> 。</p>
<h2><strong>适配器模式</strong></h2>
<p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3><strong>spring AOP中的适配器模式</strong></h3>
<p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code class="notranslate">AdvisorAdapter </code> 。Advice 常用的类型有：<code class="notranslate">BeforeAdvice</code>（目标方法调用前,前置通知）、<code class="notranslate">AfterAdvice</code>（目标方法调用后,后置通知）、<code class="notranslate">AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code class="notranslate">MethodBeforeAdviceInterceptor</code>、<code class="notranslate">AfterReturningAdviceAdapter</code>、<code class="notranslate">AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code class="notranslate">MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code class="notranslate">MethodBeforeAdviceInterceptor</code> 负责适配 <code class="notranslate">MethodBeforeAdvice</code>）。</p>
<h3><strong>spring MVC中的适配器模式</strong></h3>
<p>在Spring MVC中，<code class="notranslate">DispatcherServlet</code> 根据请求信息调用 <code class="notranslate">HandlerMapping</code>，解析请求对应的 <code class="notranslate">Handler</code>。解析到对应的 <code class="notranslate">Handler</code>（也就是我们平常说的 <code class="notranslate">Controller</code> 控制器）后，开始由<code class="notranslate">HandlerAdapter</code> 适配器处理。<code class="notranslate">HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code class="notranslate">Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code class="notranslate">Controller</code> 种类众多，不同类型的 <code class="notranslate">Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code class="notranslate">DispatcherServlet</code> 直接获取对应类型的 <code class="notranslate">Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">if</span>(<span class="pl-s1">mappedHandler</span>.<span class="pl-en">getHandler</span>() <span class="pl-k">instanceof</span> <span class="pl-smi">MultiActionController</span>){  
   ((<span class="pl-smi">MultiActionController</span>)<span class="pl-s1">mappedHandler</span>.<span class="pl-en">getHandler</span>()).<span class="pl-s1">xxx</span>  
}<span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-s1">mappedHandler</span>.<span class="pl-en">getHandler</span>() <span class="pl-k">instanceof</span> <span class="pl-smi">XXX</span>){  
    ...  
}<span class="pl-k">else</span> <span class="pl-k">if</span>(...){  
   ...  
}  </pre></div>
<p>假如我们再增加一个 <code class="notranslate">Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2><strong>装饰者模式</strong></h2>
<p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code class="notranslate">InputStream</code>家族，<code class="notranslate">InputStream</code> 类下有 <code class="notranslate">FileInputStream</code> (读取文件)、<code class="notranslate">BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code class="notranslate">InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ce687d91c85e84998e238bd9a9223638a00c2cbada296165edefdb70123ef5d1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4465636f7261746f722e6a7067"><img src="https://camo.githubusercontent.com/ce687d91c85e84998e238bd9a9223638a00c2cbada296165edefdb70123ef5d1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4465636f7261746f722e6a7067" alt="装饰者模式示意图" data-canonical-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Decorator.jpg" style="max-width: 100%;"></a></p>
<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code class="notranslate">Wrapper</code>或者 <code class="notranslate">Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2><strong>总结</strong></h2>
<p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code class="notranslate">BeanFactory</code>、<code class="notranslate">ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code class="notranslate">jdbcTemplate</code>、<code class="notranslate">hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code class="notranslate">Controller</code>。</li>
<li>......</li>
</ul>
<h2><strong>参考</strong></h2>
<ul>
<li>《Spring技术内幕》</li>
<li><a href="https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/" rel="nofollow">https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li>
<li><a href="http://blog.yeamin.top/2018/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Spring%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" rel="nofollow">http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/</a></li>
<li><a href="https://www.tutorialsteacher.com/ioc/inversion-of-control" rel="nofollow">https://www.tutorialsteacher.com/ioc/inversion-of-control</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html" rel="nofollow">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li>
<li><a href="https://juejin.im/post/5a8eb261f265da4e9e307230" rel="nofollow">https://juejin.im/post/5a8eb261f265da4e9e307230</a></li>
<li><a href="https://juejin.im/post/5ba28986f265da0abc2b6084" rel="nofollow">https://juejin.im/post/5ba28986f265da0abc2b6084</a></li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://shuaiwang888.github.io/appStore-Blog.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shuaiwang888/appStore-Blog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
