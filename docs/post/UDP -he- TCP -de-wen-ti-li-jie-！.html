<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 目录

1、UDP 和 TCP 的特点与区别

2、UDP 、TCP 首部格式

3、TCP 的三次握手和四次挥手

4、TCP 的三次握手（为什么三次？）

5、TCP 的四次挥手（为什么四次？）

6、TCP 长连接和短连接的区别

7、TCP粘包、拆包及解决办法

8、TCP 可靠传输

9、TCP 滑动窗口

10、TCP 流量控制

11、TCP 拥塞控制

12、提供网络利用率


## 前言



网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。">
<meta property="og:title" content="UDP 和 TCP 的问题理解！">
<meta property="og:description" content="## 目录

1、UDP 和 TCP 的特点与区别

2、UDP 、TCP 首部格式

3、TCP 的三次握手和四次挥手

4、TCP 的三次握手（为什么三次？）

5、TCP 的四次挥手（为什么四次？）

6、TCP 长连接和短连接的区别

7、TCP粘包、拆包及解决办法

8、TCP 可靠传输

9、TCP 滑动窗口

10、TCP 流量控制

11、TCP 拥塞控制

12、提供网络利用率


## 前言



网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shuaiwang888.github.io/appStore-Blog.github.io/post/UDP%20-he-%20TCP%20-de-wen-ti-li-jie-%EF%BC%81.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>UDP 和 TCP 的问题理解！</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}

</style>




<body>
    <div id="header">
<h1 class="postTitle">UDP 和 TCP 的问题理解！</h1>
<div class="title-right">
    <a href="https://shuaiwang888.github.io/appStore-Blog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shuaiwang888/appStore-Blog.github.io/issues/61" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>目录</h2>
<p>1、UDP 和 TCP 的特点与区别</p>
<p>2、UDP 、TCP 首部格式</p>
<p>3、TCP 的三次握手和四次挥手</p>
<p>4、TCP 的三次握手（为什么三次？）</p>
<p>5、TCP 的四次挥手（为什么四次？）</p>
<p>6、TCP 长连接和短连接的区别</p>
<p>7、TCP粘包、拆包及解决办法</p>
<p>8、TCP 可靠传输</p>
<p>9、TCP 滑动窗口</p>
<p>10、TCP 流量控制</p>
<p>11、TCP 拥塞控制</p>
<p>12、提供网络利用率</p>
<h2>前言</h2>
<p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h2>1、UDP 和 TCP 的特点与区别</h2>
<p><strong>用户数据报协议 UDP（User Datagram Protocol）：</strong></p>
<p>是<strong>无连接</strong>的，<strong>首部占用空间小</strong>，<strong>尽最大可能交付</strong>，<strong>没有拥塞控制</strong>，<strong>面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信，主要应用在音视频通话，直播</strong>等场景中。</p>
<p><strong>传输控制协议 TCP（Transmission Control Protocol）：</strong></p>
<p>是<strong>面向连接</strong>的，<strong>首部占用空间大</strong>，<strong>提供可靠交付</strong>，<strong>有流量控制，拥塞控制</strong>，提供<strong>全双工通信</strong>，<strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（<strong>一对一</strong>），主要应用在<strong>浏览器、文件传输、邮件发送</strong>等场景中。</p>
<h2>2、UDP 、TCP 首部格式</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a25e8c07a9051eef232cd47ae5e144d834b805224afad9ff0f3d244703388909/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f66356463383337393737643234323037613932353963396463346533636234632e706e67"><img src="https://camo.githubusercontent.com/a25e8c07a9051eef232cd47ae5e144d834b805224afad9ff0f3d244703388909/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f66356463383337393737643234323037613932353963396463346533636234632e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/f5dc837977d24207a9259c9dc4e3cb4c.png" style="max-width: 100%;"></a></p>
<p>UDP 首部字段只有 8 个字节，包括<strong>源端口、目的端口、长度、检验和</strong>。12 字节的伪首部是为了计算检验和临时添加的。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a1a28c66b90feda58be491c36e36c24c4e3c41c1b0028e24d5b7738cf3c5fa38/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f66376636386362636530646634353463616637306537663366373464336430612e706e67"><img src="https://camo.githubusercontent.com/a1a28c66b90feda58be491c36e36c24c4e3c41c1b0028e24d5b7738cf3c5fa38/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f66376636386362636530646634353463616637306537663366373464336430612e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/f7f68cbce0df454caf70e7f3f74d3d0a.png" style="max-width: 100%;"></a></p>
<p>TCP 首部格式比 UDP 复杂。因为是提供可靠交付，首部包括<strong>序号、确认号、数据偏移、控制位（八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN）、窗口。</strong></p>
<ol>
<li>
<p><strong>序号</strong>：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong>：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上<strong>指的是首部的长度</strong>。</p>
</li>
<li>
<p><strong>控制位</strong>：八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p>
</li>
</ol>
<ul>
<li>
<p><strong>CWR</strong>：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则<strong>通知对方已将拥塞窗口缩小</strong>；</p>
</li>
<li>
<p><strong>ECE</strong>：若其值为 1 则会通知对方，从<strong>对方到这边的网络有阻塞</strong>。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p>
</li>
<li>
<p><strong>URG</strong>：该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p>
</li>
<li>
<p><strong>ACK</strong>：<strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</strong></p>
</li>
<li>
<p><strong>PSH</strong>：该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p>
</li>
<li>
<p><strong>RST</strong>：该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p>
</li>
<li>
<p><strong>SYN</strong>：<strong>用于建立连接</strong>，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p>
</li>
<li>
<p><strong>FIN</strong>：该位设为 1，<strong>表示今后不再有数据发送，希望断开连接</strong>。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p>
</li>
<li>
<p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p>
</li>
</ul>
<ol start="5">
<li><strong>窗口</strong>：<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ol>
<h2>3、TCP 的三次握手（为什么三次？）</h2>
<p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c8cc05e05c096dc3ad635d7078c765c08ec6645b6b01850292397702741f1bac/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5463774e6a41314d5445774e4441314e6a59323f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67"><img src="https://camo.githubusercontent.com/c8cc05e05c096dc3ad635d7078c765c08ec6645b6b01850292397702741f1bac/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5463774e6a41314d5445774e4441314e6a59323f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67" alt="" data-canonical-src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png" style="max-width: 100%;"></a></p>
<p><strong>具体图解如下：</strong></p>
<ol>
<li>
<p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</p>
</li>
<li>
<p>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</p>
</li>
<li>
<p>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</p>
</li>
<li>
<p>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</p>
</li>
<li>
<p>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>
</li>
</ol>
<p><strong>为什么三次？</strong></p>
<p>1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>2、换个易于理解的视角来看为什么要 3 次握手。</p>
<ul>
<li>
<p>客户端和服务端通信前要进行连接，<strong>“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</strong></p>
</li>
<li>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
</li>
<li>
<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
</li>
<li>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。<strong>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</strong></p>
</li>
<li>
<p>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
</li>
<li>
<p><strong>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</strong></p>
</li>
<li>
<p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p>
</li>
<li>
<p>**而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。<br>
**</p>
</li>
</ul>
<h2>4、TCP 的四次挥手（为什么四次？）</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/39f7041fc3a74a5cacb8cc6715104d63bd2fc61143b05c8a0a54d30e91c19ff4/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5463774e6a41324d4467304f4455784d6a63793f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67"><img src="https://camo.githubusercontent.com/39f7041fc3a74a5cacb8cc6715104d63bd2fc61143b05c8a0a54d30e91c19ff4/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063446f764c326c745a7935696247396e4c6d4e7a5a473475626d56304c7a49774d5463774e6a41324d4467304f4455784d6a63793f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67" alt="" data-canonical-src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png" style="max-width: 100%;"></a></p>
<p><strong>具体图解如下：</strong></p>
<ol>
<li>
<p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
</li>
<li>
<p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
</li>
<li>
<p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
</li>
<li>
<p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li>
<p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
</li>
<li>
<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
</li>
</ol>
<p><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></p>
<p>1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。</p>
<p>2、这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</p>
<p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<p>3、客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p>4、因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p><strong>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</strong></p>
</li>
</ul>
<h2>5、TCP 短连接和长连接的区别</h2>
<p><strong>1. 短连接</strong>：Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。</p>
<p><strong>短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。</strong></p>
<p><strong>2. 长连接</strong>：Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>在长连接的应用场景下，<strong>Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大</strong>，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，<strong>限制每个客户端的最大长连接数</strong>，从而避免某个客户端连累后端的服务。</p>
<p>长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。</p>
<h2>6、TCP粘包、拆包及解决办法</h2>
<p>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</p>
<p>由前两节可知，<strong>UDP 是基于报文发送的</strong>，<strong>UDP首部采用了 16bit(2个字节) 来指示 UDP 数据报文的长度</strong>，因此在<strong>应用层能很好的将不同的数据报文区分开</strong>，从而避免粘包和拆包的问题。</p>
<p>而 <strong>TCP 是基于字节流的</strong>，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，<strong>在 TCP 的首部没有表示数据长度的字段</strong>，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p>
<p><strong>什么是粘包、拆包？</strong></p>
<p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p>
<ol>
<li>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/98c814b75f7cfd696868c2e0be82bfee4e8a391d917ac18b638abc47988317d1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f65393633326363653762313034653234393635356639373832663061366636322e706e67"><img src="https://camo.githubusercontent.com/98c814b75f7cfd696868c2e0be82bfee4e8a391d917ac18b638abc47988317d1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f65393633326363653762313034653234393635356639373832663061366636322e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/e9632cce7b104e249655f9782f0a6f62.png" style="max-width: 100%;"></a></p>
<ol start="2">
<li>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e23b94aa78cb8603fef7dbfb330b0ba25aa5fc7ac44b805c2f768007404f587e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64316665353239623735633234353938386334393433376662376333626166642e706e67"><img src="https://camo.githubusercontent.com/e23b94aa78cb8603fef7dbfb330b0ba25aa5fc7ac44b805c2f768007404f587e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64316665353239623735633234353938386334393433376662376333626166642e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/d1fe529b75c245988c49437fb7c3bafd.png" style="max-width: 100%;"></a></p>
<ol start="3">
<li>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b921cd357be47d562955fc83b7d49b53ad92da722399d485e8887c67d162e654/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f65316234386137393439376534613437613330333938643966656261306266372e706e67"><img src="https://camo.githubusercontent.com/b921cd357be47d562955fc83b7d49b53ad92da722399d485e8887c67d162e654/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f65316234386137393439376534613437613330333938643966656261306266372e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/e1b48a79497e4a47a30398d9feba0bf7.png" style="max-width: 100%;"></a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/93eee16e33a994534db02b1a90f0e7dd274728e56118dc1835d4b46e3ce7966e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36633365326463303731316434303830613130616235313166303230366637652e706e67"><img src="https://camo.githubusercontent.com/93eee16e33a994534db02b1a90f0e7dd274728e56118dc1835d4b46e3ce7966e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f36633365326463303731316434303830613130616235313166303230366637652e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/6c3e2dc0711d4080a10ab511f0206f7e.png" style="max-width: 100%;"></a></p>
<p><strong>为什么会发生 TCP 粘包、拆包？</strong></p>
<ol>
<li>
<p>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</p>
</li>
<li>
<p>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</p>
</li>
<li>
<p>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p>
</li>
<li>
<p>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p>
</li>
</ol>
<p><strong>粘包、拆包解决办法</strong></p>
<p><strong>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决</strong>，根据业界的主流协议的解决方案，归纳如下：</p>
<p><strong>1. 消息定长</strong>：发送端将<strong>每个数据包封装为固定长度</strong>（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p>
<p><strong>2. 设置消息边界</strong>：服务端从<strong>网络流中按消息边界分离出消息内容</strong>。在包尾增加回车换行符进行分割，例如 FTP 协议。</p>
<p><strong>3. 将消息分为消息头和消息体</strong>：消息头中包含表示消息总长度（或者消息体长度）的字段。</p>
<ol start="4">
<li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li>
</ol>
<p>7、如何保证 TCP 可靠传输</p>
<p>一句话：<strong>通过校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制等机制来保证可靠性。</strong></p>
<p><strong>（1）校验和</strong></p>
<p>在数据传输过程中，将发送的数据段都当做一个16位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。</p>
<p>发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。</p>
<p>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p><strong>（2）序列号</strong></p>
<p>TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。</p>
<p><strong>（3）确认应答 ARQ 协议</strong></p>
<p>TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。</p>
<p>它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p><strong>（4）超时重传</strong></p>
<p>在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。</p>
<p>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<p><strong>（5）连接管理</strong></p>
<p>就是指三次握手、四次挥手的过程。</p>
<p><strong>（6）流量控制</strong></p>
<p>如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。</p>
<p>具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。</p>
<p>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p><strong>（7）拥塞控制</strong></p>
<p>TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了慢启动机制，在开始发送数据的时候，先发少量的数据探探路。</p>
<h2>8、TCP 滑动窗口</h2>
<p>窗口是缓存的一部分，用来<strong>暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</strong></p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e6aa2221d3d61ce98166dd917c3ad4906476b75ec4ea5d23aabc65b3e1caa5ae/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f39613334386662353266333334653461616433333863343161336235653933642e706e67"><img src="https://camo.githubusercontent.com/e6aa2221d3d61ce98166dd917c3ad4906476b75ec4ea5d23aabc65b3e1caa5ae/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f39613334386662353266333334653461616433333863343161336235653933642e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/9a348fb52f334e4aad338c41a3b5e93d.png" style="max-width: 100%;"></a></p>
<h2>9、TCP 拥塞控制</h2>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/532b9af40bd687fb6d10ea92657b02d898a019bed55aa5033095749affc6f63b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64306630653761313734306334656439626433623939376664623830313261312e706e67"><img src="https://camo.githubusercontent.com/532b9af40bd687fb6d10ea92657b02d898a019bed55aa5033095749affc6f63b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64306630653761313734306334656439626433623939376664623830313261312e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/d0f0e7a1740c4ed9bd3b997fdb8012a1.png" style="max-width: 100%;"></a></p>
<p><strong>TCP 主要通过四个算法来进行拥塞控制：</strong></p>
<p><strong>慢开始、拥塞避免、快重传、快恢复。</strong></p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>
<p>接收方有足够大的接收缓存，因此不会发生流量控制；</p>
</li>
<li>
<p>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/35e46e170bdd238ea9aa9282a00fee2e51ad56192089a59f7a663937fc8781f4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37393536616535633066386134363864386638333938373335383866376133632e706e67"><img src="https://camo.githubusercontent.com/35e46e170bdd238ea9aa9282a00fee2e51ad56192089a59f7a663937fc8781f4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f37393536616535633066386134363864386638333938373335383866376133632e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/7956ae5c0f8a468d8f839873588f7a3c.png" style="max-width: 100%;"></a></p>
<p><strong>慢开始与拥塞避免</strong></p>
<ol>
<li>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p>
</li>
<li>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
</li>
<li>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
</li>
</ol>
<p><strong>快重传与快恢复</strong></p>
<ol>
<li>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
</li>
<li>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
</li>
<li>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
</li>
<li>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/800551d9e7665b976beb469cfb3583d2192c5dd961970a3672f7b77c12947800/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f38613334373864633764336434306265623339326438663832333536336231382e706e67"><img src="https://camo.githubusercontent.com/800551d9e7665b976beb469cfb3583d2192c5dd961970a3672f7b77c12947800/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f38613334373864633764336434306265623339326438663832333536336231382e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/8a3478dc7d3d40beb392d8f823563b18.png" style="max-width: 100%;"></a></p>
<p>10、提供网络利用率(说说 TCP 协议如何提高传输效率？)</p>
<p><strong>一句话：TCP 协议提高效率的方式有滑动窗口、快重传、延迟应答、捎带应答等。</strong></p>
<p><strong>（1）滑动窗口</strong></p>
<p>如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。</p>
<p>为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。</p>
<p><strong>（2）快重传</strong></p>
<p>快重传也叫高速重发控制。</p>
<p>那么如果出现了丢包，需要进行重传。一般分为两种情况：</p>
<p>情况一：数据包已经抵达，ACK被丢了。这种情况下，部分ACK丢了并不影响，因为可以通过后续的ACK进行确认；</p>
<p>情况二：数据包直接丢了。发送端会连续收到多个相同的 ACK 确认，发送端立即将对应丢失的数据重传。</p>
<p><strong>（3）延迟应答</strong></p>
<p>如果接收数据的主机立刻返回ACK应答，这时候返回的窗口大小可能比较小。</p>
<p>假设接收端缓冲区为1M，一次收到了512K的数据；如果立刻应答，返回的窗口就是512K；<br>
但实际上可能处理端处理速度很快，10ms之内就把512K的数据从缓存区消费掉了；<br>
在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；<br>
如果接收端稍微等一会在应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M；<br>
窗口越大，网络吞吐量就越大，传输效率就越高；我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</p>
<p><strong>（4）捎带应答</strong></p>
<p>在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而ACK响应常常伴随着数据报文共同传输。如：三次握手。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://shuaiwang888.github.io/appStore-Blog.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shuaiwang888/appStore-Blog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}



</script>


</html>
