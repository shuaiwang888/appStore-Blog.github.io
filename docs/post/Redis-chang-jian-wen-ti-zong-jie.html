<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="
### 参考文献：
[Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
[整理好了，Redis面试题(重要)](https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA)
[Redis常见面试题](https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ)
[Redis为什么变慢了？一文讲透如何排查Redis性能问题](https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw)
[Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？](https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g)
[缓存一致性问题怎么解决？](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)

## 一、简单介绍一下 Redis 呗!
如何回答：1.key-value结构存储的非关系型数据库；2.优点：内存存储、丰富数据结构、单线程IO、支持持久化；3.场景：分布式缓存、分布式锁、分布式队列、排行榜、查找附近的人等等；

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。">
<meta property="og:title" content="Redis常见问题总结">
<meta property="og:description" content="
### 参考文献：
[Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
[整理好了，Redis面试题(重要)](https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA)
[Redis常见面试题](https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ)
[Redis为什么变慢了？一文讲透如何排查Redis性能问题](https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw)
[Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？](https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g)
[缓存一致性问题怎么解决？](https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw)

## 一、简单介绍一下 Redis 呗!
如何回答：1.key-value结构存储的非关系型数据库；2.优点：内存存储、丰富数据结构、单线程IO、支持持久化；3.场景：分布式缓存、分布式锁、分布式队列、排行榜、查找附近的人等等；

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shuaiwang888.github.io/appStore-Blog.github.io/post/Redis-chang-jian-wen-ti-zong-jie.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>Redis常见问题总结</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Redis常见问题总结</h1>
<div class="title-right">
    <a href="https://shuaiwang888.github.io/appStore-Blog.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shuaiwang888/appStore-Blog.github.io/issues/26" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h3>参考文献：</h3>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md">Redis</a><br>
<a href="https://mp.weixin.qq.com/s/LkIcGS9kFTXNLFlxASPYUA" rel="nofollow">整理好了，Redis面试题(重要)</a><br>
<a href="https://mp.weixin.qq.com/s/R1TJMo2IbPUUMox9OAAafQ" rel="nofollow">Redis常见面试题</a><br>
<a href="https://mp.weixin.qq.com/s/rw42cFbJXwPtsGiqkFErfw" rel="nofollow">Redis为什么变慢了？一文讲透如何排查Redis性能问题</a><br>
<a href="https://mp.weixin.qq.com/s/mscKInWNAuhCbg183Um9_g" rel="nofollow">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br>
<a href="https://mp.weixin.qq.com/s/dYvM8_6SQnYRB6KjPsprbw" rel="nofollow">缓存一致性问题怎么解决？</a></p>
<h2>一、简单介绍一下 Redis 呗!</h2>
<p>如何回答：1.key-value结构存储的非关系型数据库；2.优点：内存存储、丰富数据结构、单线程IO、支持持久化；3.场景：分布式缓存、分布式锁、分布式队列、排行榜、查找附近的人等等；</p>
<p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>
<h2>二、分布式缓存常见的技术选型方案有哪些？</h2>
<p>分布式缓存的话，使用的比较多的主要是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p>
<h2>三、说一下 Redis 和 Memcached 的区别和共同点</h2>
<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>
<h2>四、缓存数据的处理流程是怎样的？</h2>
<p>作为暖男一号，我给大家画了一个草图。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c6bf5b31dabcc9e9741b83ea6e052451c72b4fa5d1dac14444215e1f35b68322/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545372542432539332545352541442539382545372539412538342545352541342538342545372539302538362545362542352538312545372541382538422e706e67"><img src="https://camo.githubusercontent.com/c6bf5b31dabcc9e9741b83ea6e052451c72b4fa5d1dac14444215e1f35b68322/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545372542432539332545352541442539382545372539412538342545352541342538342545372539302538362545362542352538312545372541382538422e706e67" alt="正常缓存处理流程" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="max-width: 100%;"></a></p>
<p>简单来说就是:</p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h2>五、为什么要用 Redis/为什么要用缓存？</h2>
<p><em>简单，来说使用缓存主要是为了提升用户体验以及应对更多的用户。</em></p>
<p>下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a8be7801157e5bd80756617659855a134b21b286373c5aa242fae21def8978b9/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545342542442542462545372539342541382545372542432539332545352541442539382545342542392538422545352539302538452e706e67"><img src="https://camo.githubusercontent.com/a8be7801157e5bd80756617659855a134b21b286373c5aa242fae21def8978b9/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545342542442542462545372539342541382545372542432539332545352541442539382545342542392538422545352539302538452e706e67" alt="" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E4%B9%8B%E5%90%8E.png" style="max-width: 100%;"></a></p>
<p><strong>高性能</strong> ：</p>
<p>对照上面 👆 我画的图。我们设想这样的场景：</p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；<br>
由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
</blockquote>
<h2>六、Redis 除了做缓存，还能做什么？</h2>
<ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：<a href="https://mp.weixin.qq.com/s/CbnPRfvq4m1sqo2uKI6qQw" rel="nofollow">《分布式锁中的王者方案 - Redisson》</a>。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA" rel="nofollow">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用(一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。)。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
<li>Redis如何实现延时队列？ --- 使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</li>
</ul>
<h2>七、Redis 常见数据结构以及使用场景分析</h2>
<p>你可以自己本机安装 redis 或者通过 redis 官网提供的<a href="https://try.redis.io/" rel="nofollow">在线 redis 环境</a>。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b8165c8d4ae5e42674325bff5e9ce52c7acf88a1264145006561b4cfc3c24266/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f7472792d72656469732e706e67"><img src="https://camo.githubusercontent.com/b8165c8d4ae5e42674325bff5e9ce52c7acf88a1264145006561b4cfc3c24266/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f7472792d72656469732e706e67" alt="try-redis" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/try-redis.png" style="max-width: 100%;"></a></p>
<h3>7.1 string</h3>
<ol>
<li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li>
<li><strong>常用命令：</strong> <code class="notranslate">set,get,strlen,exists,decr,incr,setex</code> 等等。</li>
<li><strong>应用场景：</strong> 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>普通字符串的基本操作：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> <span class="pl-c1">set</span> key value <span class="pl-c"><span class="pl-c">#</span>设置 key-value 类型的值</span>
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> get key <span class="pl-c"><span class="pl-c">#</span> 根据 key 获得对应的 value</span>
<span class="pl-s"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> exists key  <span class="pl-c"><span class="pl-c">#</span> 判断某个 key 是否存在</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> strlen key <span class="pl-c"><span class="pl-c">#</span> 返回 key 所储存的字符串值的长度。</span>
(integer) 5
127.0.0.1:<span class="pl-k">6379&gt;</span> del key <span class="pl-c"><span class="pl-c">#</span> 删除某个 key 对应的值</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> get key
(nil)</pre></div>
<p><strong>批量设置</strong> :</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> mset key1 value1 key2 value2 <span class="pl-c"><span class="pl-c">#</span> 批量设置 key-value 类型的值</span>
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> mget key1 key2 <span class="pl-c"><span class="pl-c">#</span> 批量获取多个 key 对应的 value</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span></pre></div>
<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> <span class="pl-c1">set</span> number 1
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> incr number <span class="pl-c"><span class="pl-c">#</span> 将 key 中储存的数字值增一</span>
(integer) 2
127.0.0.1:<span class="pl-k">6379&gt;</span> get number
<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> decr number <span class="pl-c"><span class="pl-c">#</span> 将 key 中储存的数字值减一</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> get number
<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span></pre></div>
<p><strong>过期（默认为永不过期）</strong>：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> expire key  60 <span class="pl-c"><span class="pl-c">#</span> 数据在 60s 后过期</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> setex key 60 value <span class="pl-c"><span class="pl-c">#</span> 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> ttl key <span class="pl-c"><span class="pl-c">#</span> 查看数据还有多久过期</span>
(integer) 56</pre></div>
<h3>7.2 list</h3>
<ol>
<li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
<li><strong>常用命令:</strong> <code class="notranslate">rpush,lpop,lpush,rpop,lrange,llen</code> 等。</li>
<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>通过 <code class="notranslate">rpush/lpop</code> 实现队列：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> rpush myList value1 <span class="pl-c"><span class="pl-c">#</span> 向 list 的头部（右边）添加元素</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> rpush myList value2 value3 <span class="pl-c"><span class="pl-c">#</span> 向list的头部（最右边）添加多个元素</span>
(integer) 3
127.0.0.1:<span class="pl-k">6379&gt;</span> lpop myList <span class="pl-c"><span class="pl-c">#</span> 将 list的尾部(最左边)元素取出</span>
<span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> lrange myList 0 1 <span class="pl-c"><span class="pl-c">#</span> 查看对应下标的list列表， 0 为 start,1为 end</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> lrange myList 0 -1 <span class="pl-c"><span class="pl-c">#</span> 查看列表中的所有元素，-1表示倒数第一</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span></pre></div>
<p><strong>通过 <code class="notranslate">rpush/rpop</code> 实现栈：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> rpush myList2 value1 value2 value3
(integer) 3
127.0.0.1:<span class="pl-k">6379&gt;</span> rpop myList2 <span class="pl-c"><span class="pl-c">#</span> 将 list的头部(最右边)元素取出</span>
<span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span></pre></div>
<p>我专门画了一个图方便小伙伴们来理解：</p>
<p><a target="_blank" rel="noopener noreferrer" href="./images/redis-all/redis-list.png"><img src="./images/redis-all/redis-list.png" alt="redis list" style="max-width: 100%;"></a></p>
<p><strong>通过 <code class="notranslate">lrange</code> 查看对应下标范围的列表元素：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> rpush myList value1 value2 value3
(integer) 3
127.0.0.1:<span class="pl-k">6379&gt;</span> lrange myList 0 1 <span class="pl-c"><span class="pl-c">#</span> 查看对应下标的list列表， 0 为 start,1为 end</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> lrange myList 0 -1 <span class="pl-c"><span class="pl-c">#</span> 查看列表中的所有元素，-1表示倒数第一</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
3) <span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span></pre></div>
<p>通过 <code class="notranslate">lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p><strong>通过 <code class="notranslate">llen</code> 查看链表长度：</strong></p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> llen myList
(integer) 3</pre></div>
<h3>7.3 hash</h3>
<ol>
<li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li><strong>常用命令：</strong> <code class="notranslate">hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li>
<li><strong>应用场景:</strong> 系统中对象数据的存储。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> hmset userInfoKey name <span class="pl-s"><span class="pl-pds">"</span>guide<span class="pl-pds">"</span></span> description <span class="pl-s"><span class="pl-pds">"</span>dev<span class="pl-pds">"</span></span> age <span class="pl-s"><span class="pl-pds">"</span>24<span class="pl-pds">"</span></span>
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> hexists userInfoKey name <span class="pl-c"><span class="pl-c">#</span> 查看 key 对应的 value中指定的字段是否存在。</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> hget userInfoKey name <span class="pl-c"><span class="pl-c">#</span> 获取存储在哈希表中指定字段的值。</span>
<span class="pl-s"><span class="pl-pds">"</span>guide<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hget userInfoKey age
<span class="pl-s"><span class="pl-pds">"</span>24<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hgetall userInfoKey <span class="pl-c"><span class="pl-c">#</span> 获取在哈希表中指定 key 的所有字段和值</span>
1) <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>guide<span class="pl-pds">"</span></span>
3) <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span>
4) <span class="pl-s"><span class="pl-pds">"</span>dev<span class="pl-pds">"</span></span>
5) <span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>
6) <span class="pl-s"><span class="pl-pds">"</span>24<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hkeys userInfoKey <span class="pl-c"><span class="pl-c">#</span> 获取 key 列表</span>
1) <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span>
3) <span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hvals userInfoKey <span class="pl-c"><span class="pl-c">#</span> 获取 value 列表</span>
1) <span class="pl-s"><span class="pl-pds">"</span>guide<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>dev<span class="pl-pds">"</span></span>
3) <span class="pl-s"><span class="pl-pds">"</span>24<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hset userInfoKey name <span class="pl-s"><span class="pl-pds">"</span>GuideGeGe<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> 修改某个字段对应的值</span>
127.0.0.1:<span class="pl-k">6379&gt;</span> hget userInfoKey name
<span class="pl-s"><span class="pl-pds">"</span>GuideGeGe<span class="pl-pds">"</span></span></pre></div>
<h3>7.4 set</h3>
<ol>
<li><strong>介绍 ：</strong> set 类似于 Java 中的 <code class="notranslate">HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>
<li><strong>常用命令：</strong> <code class="notranslate">sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>
<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> sadd mySet value1 value2 <span class="pl-c"><span class="pl-c">#</span> 添加元素进去</span>
(integer) 2
127.0.0.1:<span class="pl-k">6379&gt;</span> sadd mySet value1 <span class="pl-c"><span class="pl-c">#</span> 不允许有重复元素</span>
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> smembers mySet <span class="pl-c"><span class="pl-c">#</span> 查看 set 中所有的元素</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> scard mySet <span class="pl-c"><span class="pl-c">#</span> 查看 set 的长度</span>
(integer) 2
127.0.0.1:<span class="pl-k">6379&gt;</span> sismember mySet value1 <span class="pl-c"><span class="pl-c">#</span> 检查某个元素是否存在set 中，只能接收单个元素</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> sadd mySet2 value2 value3
(integer) 2
127.0.0.1:<span class="pl-k">6379&gt;</span> sinterstore mySet3 mySet mySet2 <span class="pl-c"><span class="pl-c">#</span> 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> smembers mySet3
1) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span></pre></div>
<h3>7.5 sorted set</h3>
<ol>
<li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li>
<li><strong>常用命令：</strong> <code class="notranslate">zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li>
<li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> zadd myZset 3.0 value1 <span class="pl-c"><span class="pl-c">#</span> 添加元素到 sorted set 中 3.0 为权重</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> zadd myZset 2.0 value2 1.0 value3 <span class="pl-c"><span class="pl-c">#</span> 一次添加多个元素</span>
(integer) 2
127.0.0.1:<span class="pl-k">6379&gt;</span> zcard myZset <span class="pl-c"><span class="pl-c">#</span> 查看 sorted set 中的元素数量</span>
(integer) 3
127.0.0.1:<span class="pl-k">6379&gt;</span> zscore myZset value1 <span class="pl-c"><span class="pl-c">#</span> 查看某个 value 的权重</span>
<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> zrange  myZset 0 -1 <span class="pl-c"><span class="pl-c">#</span> 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
3) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> zrange  myZset 0 1 <span class="pl-c"><span class="pl-c">#</span> 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value3<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span>
127.0.0.1:<span class="pl-k">6379&gt;</span> zrevrange  myZset 0 1 <span class="pl-c"><span class="pl-c">#</span> 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>
1) <span class="pl-s"><span class="pl-pds">"</span>value1<span class="pl-pds">"</span></span>
2) <span class="pl-s"><span class="pl-pds">"</span>value2<span class="pl-pds">"</span></span></pre></div>
<h3>7.6 bitmap</h3>
<ol>
<li><strong>介绍：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li>
<li><strong>常用命令：</strong> <code class="notranslate">setbit</code> 、<code class="notranslate">getbit</code> 、<code class="notranslate">bitcount</code>、<code class="notranslate">bitop</code></li>
<li><strong>应用场景：</strong>  <strong>利用bitmap实现bloomFilter</strong>，适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
</ol>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit mykey 7 1
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit mykey 7 0
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> getbit mykey 7
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit mykey 6 1
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit mykey 8 1
(integer) 0
<span class="pl-c"><span class="pl-c">#</span> 通过 bitcount 统计被被设置为 1 的位的数量。</span>
127.0.0.1:<span class="pl-k">6379&gt;</span> bitcount mykey
(integer) 2</pre></div>
<p>针对上面提到的一些场景，这里进行进一步说明。</p>
<p><strong>使用场景一：用户行为分析</strong><br>
很多网站为了分析你的喜好，需要研究你点赞过的内容。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 记录你喜欢过 001 号小姐姐</span>
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit beauty_girl_001 uid 1</pre></div>
<p><strong>使用场景二：统计活跃用户</strong></p>
<p>使用时间作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1</p>
<p>那么我该如何计算某几天/月/年的活跃用户呢(暂且约定，统计时间内只要有一天在线就称为活跃)，有请下一个 redis 的命令</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</span>
<span class="pl-c"><span class="pl-c">#</span> BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数</span>
BITOP operation destkey key [key ...]</pre></div>
<p>初始化数据：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> setbit 20210308 1 1
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit 20210308 2 1
(integer) 0
127.0.0.1:<span class="pl-k">6379&gt;</span> setbit 20210309 1 1
(integer) 0</pre></div>
<p>统计 20210308~20210309 总活跃用户数: 1</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> bitop and desk1 20210308 20210309
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> bitcount desk1
(integer) 1</pre></div>
<p>统计 20210308~20210309 在线活跃用户数: 2</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> bitop or desk2 20210308 20210309
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> bitcount desk2
(integer) 2</pre></div>
<p><strong>使用场景三：用户在线状态</strong></p>
<p>对于获取或者统计用户在线状态，使用 bitmap 是一个节约空间且效率又高的一种方法。</p>
<p>只需要一个 key，然后用户 ID 为 offset，如果在线就设置为 1，不在线就设置为 0。</p>
<h2>八、Redis 单线程模型详解</h2>
<p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code class="notranslate">Selector</code> 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p>
<p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。<br>
可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
</blockquote>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ba07f7323d05ac4380869d15a9daa439e2e8b37ff6ed9180346803ec461c05d2/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545342542412538422545342542422542362545352541342538342545372539302538362545352539392541382e706e67"><img src="https://camo.githubusercontent.com/ba07f7323d05ac4380869d15a9daa439e2e8b37ff6ed9180346803ec461c05d2/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545342542412538422545342542422542362545352541342538342545372539302538362545352539392541382e706e67" alt="" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" style="max-width: 100%;"></a></p>
<p>《Redis设计与实现：12章》</p>
<h2>九、Redis 没有使用多线程？为什么不使用多线程？</h2>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8f430c75e2b28fda44a92dc1a18990c56d815d87f39b920b25cebad6e2c73b93/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f7265646973342e302d6d6f72652d7468726561642e706e67"><img src="https://camo.githubusercontent.com/8f430c75e2b28fda44a92dc1a18990c56d815d87f39b920b25cebad6e2c73b93/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f7265646973342e302d6d6f72652d7468726561642e706e67" alt="redis4.0 more thread" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis4.0-more-thread.png" style="max-width: 100%;"></a></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p>
<p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p>
<p><strong>那，Redis6.0 之前 为什么不使用多线程？</strong></p>
<p>我觉得主要原因有下面 3 个：</p>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h2>十、Redis6.0 之后为何引入了多线程？</h2>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code class="notranslate">redis.conf</code> ：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">io-threads-do-reads yes</pre></div>
<p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code class="notranslate">redis.conf</code> :</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">io-threads 4 <span class="pl-c"><span class="pl-c">#</span>官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></pre></div>
<p>推荐阅读：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" rel="nofollow">Redis 6.0 新特性-多线程连环 13 问！</a></li>
<li><a href="https://draveness.me/whys-the-design-redis-single-thread/" rel="nofollow">为什么 Redis 选择单线程模型</a></li>
</ol>
<h2>十一、Redis 给缓存数据设置过期时间有啥用？</h2>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">127.0.0.1:<span class="pl-k">6379&gt;</span> exp key 60 <span class="pl-c"><span class="pl-c">#</span> 数据在 60s 后过期</span>
(integer) 1
127.0.0.1:<span class="pl-k">6379&gt;</span> setex key 60 value <span class="pl-c"><span class="pl-c">#</span> 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
OK
127.0.0.1:<span class="pl-k">6379&gt;</span> ttl key <span class="pl-c"><span class="pl-c">#</span> 查看数据还有多久过期</span>
(integer) 56</pre></div>
<p>注意：**Redis 中除了字符串类型有自己独有设置过期时间的命令 <code class="notranslate">setex</code> 外，其他方法都需要依靠 <code class="notranslate">expire</code> 命令来设置过期时间 。另外， <code class="notranslate">persist</code> 命令可以移除一个键的过期时间。 **</p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2>十二、Redis 是如何判断数据是否过期的呢？</h2>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7de7e1b0b0eb6807a9202908a703b2772ab54847132d1d1bf993c5fb8044c0cd/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545382542462538372545362539432539462545362539372542362545392539372542342e706e67"><img src="https://camo.githubusercontent.com/7de7e1b0b0eb6807a9202908a703b2772ab54847132d1d1bf993c5fb8044c0cd/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545382542462538372545362539432539462545362539372542362545392539372542342e706e67" alt="redis过期字典" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.png" style="max-width: 100%;"></a></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-smi">redisDb</span> {
    ...
    <span class="pl-smi">dict</span> <span class="pl-c1">*</span><span class="pl-c1">dict</span>;     <span class="pl-c">//数据库键空间,保存着数据库中所有键值对</span>
    <span class="pl-smi">dict</span> <span class="pl-c1">*</span><span class="pl-c1">expires</span>   <span class="pl-c">// 过期字典,保存着键的过期时间</span>
    ...
} <span class="pl-smi">redisDb</span>;</pre></div>
<h2>十三、过期的数据的删除策略了解么？</h2>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h2>十四、Redis 内存淘汰机制了解么？</h2>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?<br>
Redis 提供 6 种数据淘汰策略：</p>
</blockquote>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2>十五、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h2>
<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p><strong>RDB的原理是什么？</strong></p>
<p><strong>fork和cow</strong>。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<pre lang="conf" class="notranslate"><code class="notranslate">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</code></pre>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<pre lang="conf" class="notranslate"><code class="notranslate">appendonly yes
</code></pre>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code class="notranslate">server.aof_buf</code> 中，然后再根据 <code class="notranslate">appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code class="notranslate">appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<pre lang="conf" class="notranslate"><code class="notranslate">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
</code></pre>
<p>为了兼顾数据和写入性能，用户可以考虑 <code class="notranslate">appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>相关 issue</strong> ：<a href="https://github.com/Snailclimb/JavaGuide/issues/783" data-hovercard-type="issue" data-hovercard-url="/Snailclimb/JavaGuide/issues/783/hovercard">783：Redis 的 AOF 方式</a></p>
<p><strong>拓展：Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code class="notranslate">aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p>官方文档地址：<a href="https://redis.io/topics/persistence" rel="nofollow">https://redis.io/topics/persistence</a></p>
<p><strong>补充内容：AOF 重写</strong></p>
<p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<h2>十六、Redis 事务</h2>
<p>Redis 可以通过 <strong><code class="notranslate">MULTI</code>，<code class="notranslate">EXEC</code>，<code class="notranslate">DISCARD</code> 和 <code class="notranslate">WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-k">&gt;</span> MULTI
OK
<span class="pl-k">&gt;</span> SET USER <span class="pl-s"><span class="pl-pds">"</span>Guide哥<span class="pl-pds">"</span></span>
QUEUED
<span class="pl-k">&gt;</span> GET USER
QUEUED
<span class="pl-k">&gt;</span> EXEC
1) OK
2) <span class="pl-s"><span class="pl-pds">"</span>Guide哥<span class="pl-pds">"</span></span></pre></div>
<p>使用 <a href="https://redis.io/commands/multi" rel="nofollow"><code class="notranslate">MULTI</code></a> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec" rel="nofollow"><code class="notranslate">EXEC</code></a> 命令将执行所有命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code class="notranslate">MULTI</code>）。</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li>
<li>执行事务(<code class="notranslate">EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard" rel="nofollow"><code class="notranslate">DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-k">&gt;</span> MULTI
OK
<span class="pl-k">&gt;</span> SET USER <span class="pl-s"><span class="pl-pds">"</span>Guide哥<span class="pl-pds">"</span></span>
QUEUED
<span class="pl-k">&gt;</span> GET USER
QUEUED
<span class="pl-k">&gt;</span> DISCARD
OK</pre></div>
<p><a href="https://redis.io/commands/watch" rel="nofollow"><code class="notranslate">WATCH</code></a> 命令用于监听指定的键，当调用 <code class="notranslate">EXEC</code> 命令执行事务时，如果一个被 <code class="notranslate">WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-k">&gt;</span> WATCH USER
OK
<span class="pl-k">&gt;</span> MULTI
<span class="pl-k">&gt;</span> SET USER <span class="pl-s"><span class="pl-pds">"</span>Guide哥<span class="pl-pds">"</span></span>
OK
<span class="pl-k">&gt;</span> GET USER
Guide哥
<span class="pl-k">&gt;</span> EXEC
ERR EXEC without MULTI</pre></div>
<p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions" rel="nofollow">https://redis.io/topics/transactions</a> 如下：</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ad1815f60882ce92d396acbe686b53869d755ff9d3d2357767823423faced593/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545342542412538422545352538412541312e706e67"><img src="https://camo.githubusercontent.com/ad1815f60882ce92d396acbe686b53869d755ff9d3d2357767823423faced593/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732545342542412538422545352538412541312e706e67" alt="redis事务" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E5%8A%A1.png" style="max-width: 100%;"></a></p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9f1b28491583f7503fb9d8970a2300e10beee70aac6d2ab46dcc7c79b744a3b1/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732d726f6c6c4261636b2e706e67"><img src="https://camo.githubusercontent.com/9f1b28491583f7503fb9d8970a2300e10beee70aac6d2ab46dcc7c79b744a3b1/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f72656469732d726f6c6c4261636b2e706e67" alt="redis roll back" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis-rollBack.png" style="max-width: 100%;"></a></p>
<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p><strong>相关 issue</strong> :</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/452" data-hovercard-type="issue" data-hovercard-url="/Snailclimb/JavaGuide/issues/452/hovercard">issue452: 关于 Redis 事务不满足原子性的问题</a> 。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/491" data-hovercard-type="issue" data-hovercard-url="/Snailclimb/JavaGuide/issues/491/hovercard">Issue491:关于 redis 没有事务回滚？</a></li>
</ul>
<h2>十七、缓存穿透</h2>
<h3>17.1 什么是缓存穿透？</h3>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3>17.2 缓存穿透情况的处理流程是怎样的？</h3>
<p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5eeb722510433a31ac930b75fb0042480ac91340d44d242bf2b1bd83bcb38be7/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545372542432539332545352541442539382545372541392542462545392538302538462545362538332538352545352538362542352e706e67"><img src="https://camo.githubusercontent.com/5eeb722510433a31ac930b75fb0042480ac91340d44d242bf2b1bd83bcb38be7/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545372542432539332545352541442539382545372541392542462545392538302538462545362538332538352545352538362542352e706e67" alt="缓存穿透情况" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%83%85%E5%86%B5.png" style="max-width: 100%;"></a></p>
<h3>17.3 有哪些解决办法？</h3>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code class="notranslate">SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code class="notranslate">表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div class="highlight highlight-source-java"><pre class="notranslate"><span class="pl-k">public</span> <span class="pl-smi">Object</span> <span class="pl-en">getObjectInclNullById</span>(<span class="pl-smi">Integer</span> <span class="pl-s1">id</span>) {
    <span class="pl-c">// 从缓存中获取数据</span>
    <span class="pl-smi">Object</span> <span class="pl-s1">cacheValue</span> = <span class="pl-s1">cache</span>.<span class="pl-en">get</span>(<span class="pl-s1">id</span>);
    <span class="pl-c">// 缓存为空</span>
    <span class="pl-k">if</span> (<span class="pl-s1">cacheValue</span> == <span class="pl-c1">null</span>) {
        <span class="pl-c">// 从数据库中获取</span>
        <span class="pl-smi">Object</span> <span class="pl-s1">storageValue</span> = <span class="pl-s1">storage</span>.<span class="pl-en">get</span>(<span class="pl-s1">key</span>);
        <span class="pl-c">// 缓存空对象</span>
        <span class="pl-s1">cache</span>.<span class="pl-en">set</span>(<span class="pl-s1">key</span>, <span class="pl-s1">storageValue</span>);
        <span class="pl-c">// 如果存储数据为空，需要设置一个过期时间(300秒)</span>
        <span class="pl-k">if</span> (<span class="pl-s1">storageValue</span> == <span class="pl-c1">null</span>) {
            <span class="pl-c">// 必须设置过期时间，否则有被攻击的风险</span>
            <span class="pl-s1">cache</span>.<span class="pl-en">expire</span>(<span class="pl-s1">key</span>, <span class="pl-c1">60</span> * <span class="pl-c1">5</span>);
        }
        <span class="pl-k">return</span> <span class="pl-s1">storageValue</span>;
    }
    <span class="pl-k">return</span> <span class="pl-s1">cacheValue</span>;
}</pre></div>
<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a4c84091bc0bd9aedab6b565c04e7e19e87819b94effab5fee563505625cc88c/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545352538412541302545352538352541352545352542382538332545392539412538362545382542462538372545362542422541342545352539392541382545352539302538452545372539412538342545372542432539332545352541442539382545352541342538342545372539302538362545362542352538312545372541382538422e706e67"><img src="https://camo.githubusercontent.com/a4c84091bc0bd9aedab6b565c04e7e19e87819b94effab5fee563505625cc88c/68747470733a2f2f736e61696c636c696d622e67697465652e696f2f6a61766167756964652f646f63732f64617461626173652f52656469732f696d616765732f72656469732d616c6c2f2545352538412541302545352538352541352545352542382538332545392539412538362545382542462538372545362542422541342545352539392541382545352539302538452545372539412538342545372542432539332545352541442539382545352541342538342545372539302538362545362542352538312545372541382538422e706e67" alt="image" data-canonical-src="https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="max-width: 100%;"></a></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/cs-basics/data-structure/bloom-filter.md">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h2>十八、缓存雪崩</h2>
<h3>18.1 什么是缓存雪崩？</h3>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h3>18.2 有哪些解决办法？</h3>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h2>十九、如何保证缓存和数据库数据的一致性？</h2>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h2>二十、3种常用的缓存读写策略</h2>
<p>看到很多小伙伴简历上写了“<strong>熟练使用缓存</strong>”，但是被我问到“<strong>缓存常用的3种读写策略</strong>”的时候却一脸懵逼。</p>
<p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。</p>
<p>但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！</p>
<p>下面我会简单介绍一下自己对于这 3 种缓存读写策略的理解。</p>
<p>另外，<strong>这3种缓存读写策略各有优劣，不存在最佳，需要我们根据具体的业务场景选择更适合的。</strong></p>
<p><em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！——爱你们的 Guide 哥</em></p>
<h3>20.1 Cache Aside Pattern（旁路缓存模式）</h3>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新 DB</li>
<li>然后直接删除 cache 。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/76e27e4243d8438310ea1bcd08f4ed918123bc68944c2b3e48318dffe93ea7dc/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f35363837666537353961316461633965643935353464323765336132336236642e706e67"><img src="https://camo.githubusercontent.com/76e27e4243d8438310ea1bcd08f4ed918123bc68944c2b3e48318dffe93ea7dc/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f35363837666537353961316461633965643935353464323765336132336236642e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png" style="max-width: 100%;"></a></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e1fd30ae87e5d981787881c9d1cd6b70a1e722ce1e4dd3cc98229351969cfa29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f61386331386235663562316165643033323334626362626438633137336138372e706e67"><img src="https://camo.githubusercontent.com/e1fd30ae87e5d981787881c9d1cd6b70a1e722ce1e4dd3cc98229351969cfa29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f61386331386235663562316165643033323334626362626438633137336138372e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png" style="max-width: 100%;"></a></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。<br>
当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong>”</p>
</blockquote>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p>
<p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。<br>
现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
</blockquote>
<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3>20.2 Read/Write Through Pattern（读写穿透）</h3>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f23af8d0a01fc618b2b4a88963895c1356ce8c412931d5d231706c8b3aca7af8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230313130303334303830382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c334678587a4d304d7a4d334d6a63792c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/f23af8d0a01fc618b2b4a88963895c1356ce8c412931d5d231706c8b3aca7af8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230313130303334303830382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c334678587a4d304d7a4d334d6a63792c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="" data-canonical-src="https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70" style="max-width: 100%;"></a></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/dc79133e3b3182efdeaf776260979569dcc6c116c1bfef77b7b9269ad5251b88/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f39616461373537633738363134393334616361313133303666333334363338642e706e67"><img src="https://camo.githubusercontent.com/dc79133e3b3182efdeaf776260979569dcc6c116c1bfef77b7b9269ad5251b88/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f39616461373537633738363134393334616361313133303666333334363338642e706e67" alt="" data-canonical-src="https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png" style="max-width: 100%;"></a></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h3>20.3 Write Behind Pattern（异步缓存写入）</h3>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://shuaiwang888.github.io/appStore-Blog.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shuaiwang888/appStore-Blog.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
