## 简介

- X项目将要接入多种硬件设备，在开发、测试、生产几个不同的阶段，设备需要接入不同的软件环境，基于多租户的设备中心只能部署在单一环境中，无法解决设备在不同环境之间分配和切换的问题。**物联网中台同样基于多租户权限系统**，每个租户可以对设备进行分组管理，每个分组对应一种软件环境，物联网中台对外提供openAPI，部署在不同环境中的设备中心可以通过openAPI获取设备、进行设备相关的所有操作。


- 参考了阿里云、华为云等物联网平台产品，按照现阶段X项目需求最小集的要求，引入了产品、设备、物模型、南向接口、北向接口、规则引擎等产品模块，可以实现物联网中台的必要功能，同时保留了扩展的可能性。

## 一、 验证方式

### 1.公共请求头参数

**注：所有接口传参数编码均为UTF_8**

|参数名称|必选|类型|描述|
|------|-------|-------|-----|
|version|是|String|公共参数，本接口取值：1.0.0|
|keyId|是|String|密钥的唯一标识|
|signatureValue|是|String|签名结果串|
|timesStamp|是|Long|时间戳|本接口取值:1638884197012|
|signType|是|String|签名算法目前持SHA256|本接口取值:SHA256|

### 2.签名方法

**物联网平台会对每个接口访问请求的发送者进行身份验证**，所以无论使用HTTP还是HTTPS协议提交请求，都需要在请求中包含签名（signatureValue）信息。

签名时，您需申请您的 `keyId` 和 `AccessKey Secret`，然后进行加密。其中，`keyId` 用于标识访问者身份；`AccessKey Secret` 是用于加密签名字符串和服务器端验证签名字符串的密钥，必须严格保密。

**(1) 拼接规范请求串**

```Plain Text
CanonicalRequest =
    HTTPRequestMethod + '\n' +
    CanonicalURI + '\n' +
    CanonicalQueryString + '\n' +
    CanonicalHeaders + '\n' +
    HashedRequestPayload
```

| 字段名称 |解释|
|------- |---- |
|**HTTPRequestMethod**| `HTTP` 请求方法（GET、POST ）。此示例取值为 POST。|
|**CanonicalURI**| `URI` 参数，则为 `URL` 中问号（?）前面的字符串内容。**注意：`CanonicalURI` 需要 进行 `URLEncode`，字符集 `UTF8`，推荐使用编程语言标准库，所有特殊字符均需编码，大写形式。**|
|**CanonicalQueryString**|发起 `HTTP` 请求 `URL` 中的查询字符串，对于 `POST` 请求，固定为空字符串""，对于 `GET` 请求，则为 `URL` 中问号（?）后面的字符串内容，例如：`Limit=10&Offset=0`。**注意：** `CanonicalQueryString` 需要进行 `URLEncode`，字符集 `UTF8`，推荐使用编程语言标准库，所有特殊字符均需编码，大写形式。|
|**CanonicalHeaders**|参与签名的头部信息拼接规则：**1.** 头部 `key` 和 `value` 统一转成小写，并去掉首尾空格，按照 `key:value\n` 格式拼接；**2.** 多个头部，严格按照头部公共参数列表排序；**3.** 只有公共参数参与签名;此示例计算结果是	`version=1.0\nkeyId=app\ntimestamp=1639658871037\nsignType=SHA256\n`|
|**HashedRequestPayload**|	请求正文（payload，即 body，此示例为`{"productKey":"321","deviceName":"1213","deviceSn":"wwew"}` 的哈希值，计算伪代码为 `Lowercase(HexEncode(Hash.SHA256(RequestPayload)))`，即对 `HTTP` 请求正文做 `SHA256` 哈希，然后十六进制编码，最后编码串转换成小写字母。对于 GET 请求，RequestPayload 固定为空字符串。此示例计算结果是 `fde4222b5a43e4c6683afe14bd9a7213d26beffead0b0ad335b4fab01809d829`。**1.** 多个参数，严格按照参数列表排序；**2.** 如果字段不必传 错误： `{"productKey":"321","deviceName":null,"deviceSn":"wwew"}`，正解： `{"productKey":"321","deviceSn":"wwew"}`|

根据以上规则，示例中得到的规范请求串如下：

```Text
POST
https%3A%2F%2Faiot.corp.kuaishou.com%2Fapi%2Fopen%2FregisterDevice

version=1.0
keyId=app
timestamp=1639658871037
signType=SHA256

fde4222b5a43e4c6683afe14bd9a7213d26beffead0b0ad335b4fab01809d829
```

**(2) 拼接待签名字符串**

按如下格式拼接待签名字符串：

```Text
StringToSign =
    signType + \n +
    timesStamp + \n +
    HashedCanonicalRequest
```


|字段名称|解释|
|------|-----|
|**signType**|签名算法，目前固定为 `SHA256`。|
|**timesStamp**|请求时间戳，即请求头部的公共参数 `timesStamp` 取值，取当前时间 `UNIX` 时间戳，精确到秒。此示例取值为 `1639658871037`。|
|**HashedCanonicalRequest**|前述步骤拼接所得规范请求串的哈希值，计算伪代码为 `Lowercase(HexEncode(Hash.SHA256(CanonicalRequest)))`。此示例计算结果是 `bfbef516b50692a2efdd2cdb338b8a8cbbed942529677447f29a3dec96434495`。|

根据以上规则，示例中得到的待签名字符串如下：

```Text
SHA256
1639658871037
bfbef516b50692a2efdd2cdb338b8a8cbbed942529677447f29a3dec96434495
```

**(3) 计算签名**

**计算派生签名密钥，伪代码如下：**

```Text
SecretKey = "Gu5t9xGARNpq86cd98joQYCN3*******"
service="kuaishou";
```


|字段名称|解释|
|------|-------|
|**SecretKey**|原始的 `SecretKey`，即 `Gu5t9xGARNpq86cd98joQYCN3*******`。|
|**service**|业务标识 固定为` kuaishou`|

```Text
secretData = hmac256((SECRET_KEY).getBytes(UTF8), service);

 signature = DatatypeConverter.printHexBinary(hmac256(secretData, stringToSign)).toLowerCase();
```
此示例计算结果是:
`1e8ebcf6e2dacc2b948913c29cd1a395a6613c5a4cef0e9eb5a14a612e5794a1`。

## 二、验证实例

以下是设备或者ESB系统向物联网中台发送请求前需要计算的一个验签值，作为请求头的参数签名结果串 `signatureValue`

```java
package com.kuaishou.ee.iot.service.util;

/**
 * @author 
 * Created on 2021-12-15
 */

import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class SignDemo {
private final static Charset UTF8 = StandardCharsets.UTF_8;

private final static String SECRET_KEY = "Gu5t9xGARNpq86cd98joQYCN3*******";

public static String percentEncode(String value) {
    try {
        // 使用URLEncoder.encode编码后，将"+","*","%7E"做替换即满足API规定的编码规范。
        return value == null ? null
                             : URLEncoder.encode(value, "utf8").replace("+", "%20").replace("*", "%2A").replace("%7E",
                                     "~");
    } catch (Exception e) {

    }
    return "";
}

public static byte[] hmac256(byte[] key, String msg) throws Exception {
    Mac mac = Mac.getInstance("HmacSHA256");
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, mac.getAlgorithm());
    mac.init(secretKeySpec);
    return mac.doFinal(msg.getBytes(UTF8));
}

public static String sha256Hex(String s) throws Exception {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    byte[] d = md.digest(s.getBytes(UTF8));
    return DatatypeConverter.printHexBinary(d).toLowerCase();
}


public static void main(String[] args) throws Exception {

    //公共参数
        String version = "1.0.0";
        String keyId = "app";
        Long timestamp = System.currentTimeMillis();
        String signType = "SHA256";
        // ************* 步骤 1：拼接规范请求串 *************
        String httpRequestMethod = "POST";
        String canonicalUri = percentEncode("https://xxx.com/api/open/reportDeviceStatus");
        String canonicalQueryString = "";
        String canonicalHeaders = "version=1.0.0\nkeyId=app\ntimestamp=" + timestamp + "\nsignType=SHA256\n";
        String payload = "{\"state\":\"3\",\"lastHeartTime\":1640227793762,\"activeTime\":1640227793762,\"iotId\":\"0004000001\"}";
        String hashedRequestPayload = sha256Hex(payload);
        String canonicalRequest = httpRequestMethod + "\n" + canonicalUri + "\n" + canonicalQueryString + "\n"
                + canonicalHeaders + "\n" + hashedRequestPayload;
        System.out.println(canonicalRequest);

        // ************* 步骤 2：拼接待签名字符串 *************
        String hashedCanonicalRequest = sha256Hex(canonicalRequest);
        String stringToSign = signType + "\n" + timestamp + "\n" + hashedCanonicalRequest;
        System.out.println(stringToSign);

        // ************* 步骤 3：计算签名 *************

        byte[] secretDate = hmac256((SECRET_KEY).getBytes(UTF8), OpenConstant.SERVICE);

        String signature = DatatypeConverter.printHexBinary(hmac256(secretDate, stringToSign)).toLowerCase();
        System.out.println(signature);
   }
}

```

**上述代码计算得到的值signature是作为请求头参数，去请求物联网中台的接口，此时物联网中台也会根据请求来到的各种参数计算出一个值，与上述该值进行比较：相同则为验签通过，可以执行请求改接口的业务逻辑，否则返回错误信息！**

以下就是验证demo：

```java
package com.kuaishou.ee.iot.service.util;

import com.kuaishou.ee.iot.common.exceptions.BusinessException;

import javax.xml.bind.DatatypeConverter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

/**
 * 
 * Created on 2021-12-17
 */


public class CheckSignUtil {

    /***
     * 密钥
     */
    private final static String SECRET_KEY = "Gu5t9xGARNpq86cd98joQYCN3*******";
    /***
     * 系统标识
     */
    private final static String KEY_ID = "app";
    /***
     * 加密方式
     */
    private final static String SIGN_TYPE = "SHA256";
    /***
     * 服务名称
     */
    private final static String SERVICE = "kuaishou";
    /***
     * 请求方式
     */
    private final static String HTTP_REQUEST_METHOD = "POST";
    /**
     * 版本
     */
    private final static String VERSION = "1.0.0";

    private final static String LINE_FEED = "\n";
    /**
     * 编码方式
     */
    private final static Charset UTF8 = StandardCharsets.UTF_8;

    /***
     * 效验签名
     * @param version
     * @param keyId
     * @param signatureValue
     * @param timesStamp
     * @param signType
     * @param bodyJson
     * @param url
     * @return
     * @throws Exception
     */
    public static   Boolean   checkSign(String version,
                             String keyId,
                             String signatureValue,
                             Long timesStamp,
                             String signType, String bodyJson, String url) throws Exception {

        if (!version.equals(VERSION)) {
            throw new BusinessException("version fail");
        }
        if (!keyId.equals(KEY_ID)) {
            throw new BusinessException("keyId  fail");
        }
        if (!signType.equals(SIGN_TYPE)) {
            throw new BusinessException("signType  fail");
        }

        String canonicalUri = SignUtil.percentEncode(url);
        String canonicalQueryString = "";
        String canonicalHeaders = "version=" + version + LINE_FEED + "keyId=" + keyId + LINE_FEED + "timestamp=" + timesStamp + LINE_FEED + "signType=" + signType + LINE_FEED;

        String hashedRequestPayload = SignUtil.sha256Hex(bodyJson);
        String canonicalRequest = HTTP_REQUEST_METHOD + LINE_FEED + canonicalUri + LINE_FEED + canonicalQueryString + LINE_FEED
                + canonicalHeaders + LINE_FEED + hashedRequestPayload;


        // ************* 步骤 2：拼接待签名字符串 *************
        String hashedCanonicalRequest = SignUtil.sha256Hex(canonicalRequest);
        String stringToSign = signType + LINE_FEED + timesStamp + LINE_FEED + hashedCanonicalRequest;


        // ************* 步骤 3：计算签名 *************
        byte[] secretDate = SignUtil.hmac256((SECRET_KEY).getBytes(UTF8), SERVICE);
        String signature = DatatypeConverter.printHexBinary(SignUtil.hmac256(secretDate, stringToSign)).toLowerCase();
        if (!signature.equals(signatureValue)) {
            throw new BusinessException("signatureValue  fail");
        }

        return true;
    }

}
```

## 四、总结

以上就是物联网中台南向对外公开的接口，验签只是在下面的直连设备或者ESB系统发来的请求接口才会出现，而由物联网中台下发的请求指令是不会由我们进行验证的，只是在下发请求时，需要计算具体某个设备的url，由于各个设备的url是变化的，所以不能由Client进行服务间的调用，需要进行一个请求url的计算，而且还需要自定义请求头！

**猜你感兴趣：**
- [SHA256算法原理详解](https://blog.csdn.net/u011583927/article/details/80905740)