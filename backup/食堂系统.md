## 一、分布式事务

### 1. 采用本地消息表来解决分布式事务
- A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
- 接着 A 系统将这个消息发送到 MQ 中去（**或者使用open feign进行远程调用**）；
- B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息（**也或者直接是通过远程调用后的幂等性判断**）；
- B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态（这里特别需要修改A系统的消息表状态）；
- 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理（**会有一个重试失败次数，如果超过规定数就会发送消息到开发者手动处理**）；
- 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。


### 2. 举例 -- 取消美餐

1. 请求美餐取消接口后，会先通过userName、orderId来加分布式锁。
2. 其次就是条件判断：当前订单状态是否可以取消？ 请求工卡数据是否正常？ 
3. 回滚：更新本系统的订单状态、美餐外卖菜品的库存、餐柜的库存、能量点、美餐系统
```java
    /**
     * 单人餐取消订单
     * @param
     * @param order 订单数据
     * @return 标准结果
     */
    private CommonResult cancelMeiCanOrder(BoxOrderEntity order, String operator) {

        Result<EnergyAccountDto> energyAccountDtoResult = energyCenterService.findCardAccountInfo(order.getUserId());
        if (energyAccountDtoResult.getCode() != ResultCode.SUCCESS.getCode()) {
            throw new BusinessException(ResultCode.FIND_CARD_ERROR);
        }

        checkMeicanOrderStatus(order);
        checkCardStatus(energyAccountDtoResult.getResult());
        updateOrderStatus(order.getId(), operator);
        rollbackDishStock(order); // 美餐外卖菜品的库存+1
        rollbackSideboardBoxStock(order); // 餐柜的库存+1
        synEnergyCenterCancel(order); // 能量点
        asynMeicanCancel(order); // 美餐系统
        return ResultUtils.success();
    }
```
- 3.1 菜品和餐柜库存都是在本系统中直接更新数据库；
- 3.2 **能力点处理回滚** --- 这里并没有能量点回滚事件，而是直接间隔500ms，重复3次远程调用能量点中心进行回滚。
```java
    public void synEnergyCenterCancel(BoxOrderEntity order){

        int retryCount = 0;
        boolean retryFlag = true;
        EnergyAccountUnPayRequest unPayRequest = constructUnPayRequest(order);
        Result<String> unPayResult = null;
        while (retryFlag) {
            try {
                unPayResult = energyCenterService.unPay(unPayRequest);
                if (unPayResult.getCode() != ResultCode.ENERGY_CENTER_CANCEL_PAY_ERROR.getCode()) {
                    retryFlag = false;
                } else {
                    Thread.sleep(500);
                    retryCount++;
                    retryFlag = retryCount < 3;
                }
            } catch (Exception e) {
                log.error("异常重试：", e);
                retryCount ++;
                retryFlag = retryCount < 3;
            }
        }
        if (unPayResult != null && unPayResult.getCode() == ResultCode.SUCCESS.getCode()) {
            log.info("cancel energy center success: orderId:{}, zhipanSeq: {}", order.getId(), order.getSovellSeq());
        } else {
            sendWxMessage(BaseConstants.SYSTEM_MESSAGE_RECEIVE_USERS, String.format("能量点中心取消异常: 订单号:%s", order.getOrderNo()));
            log.info("save energy center cancel event");
            throw new BusinessException(ResultCode.ENERGY_CENTER_CANCEL_PAY_ERROR);
        }
    }
```

- 3.3 **美餐系统处理回滚** --- 如果订单是待接单状态，可以直接存储取消美餐订单事件（因为还未接单，美餐系统并没有订单记录），如果是其他状态便直接调用美餐系统取消接口，成功直接返回，不成功则需要存储取消美餐事件且为未处理状态。

```java
    private void asynMeicanCancel(BoxOrderEntity order){
        new Thread(() -> {
            if(order.getStatus().equals(OrderStatus.ORDERING.getCode())){
                log.info("save meican cancel event");
                saveMeicanCancelEvent(order.getId());
            }else{
                CancelOrderDto cancelOrderDto = meiCanV2Service.cancelOrder(order.getCorp(), order.getMeicanOrderId());
                log.info("asynMeicanCancel:cancelOrderDto is {}", cancelOrderDto);
                if (cancelOrderDto != null && (MEICAN_OK.equals(cancelOrderDto.getResultCode()) ||
                        DELETE_CODE.equals(cancelOrderDto.getResultCode()))){
                    log.info("cancel meican success: orderId:{}, zhipanSeq: {}", order.getId(), order.getMeicanOrderId());
                }else{
                    log.info("save meican cancel event");
                    saveMeicanCancelEvent(order.getId());
                }
            }
        }).start();
    }
```
4. 每5s扫描一次事件表，每次取10条，通过事件类型来分别处理，下面是举例说明取消美餐事件。

- 4.1 取出来的条件是事件状态是未处理的；
```java
/**
     * 每5s扫描一次事件表
     */
    @Scheduled(cron = "0/15 * * * * ?")
    public void handleV2Event() {
        QueryWrapper<EventHandleEntity> queryWrapper = new QueryWrapper<EventHandleEntity>();
        //每次取100条？不是10条？，防止oom
        queryWrapper.eq("handle_status", EventHandleStatus.NOT_HANDLED).last("limit 10");
        List<EventHandleEntity> eventEntityList = iEventHandleService.list(queryWrapper);
        if(CollectionUtils.isEmpty(eventEntityList)) return;
        int meicanAddOrderErrorNum = 0;
        for(EventHandleEntity eventHandleEntity: eventEntityList){
            if(eventHandleEntity.getEventType() == EventType.ENERGY_CENTER_V2_CANCEL){
                BoxOrderEntity orderEntity = boxOrderService.getById(eventHandleEntity.getOrderId());
                orderV2Service.doEnergyCenterCancel(orderEntity, eventHandleEntity.getId(), eventHandleEntity.getRetryNum());
            }else if(eventHandleEntity.getEventType() == EventType.MEICAN_V2_CANCEL){
                OrderModel orderModel = orderMapper.queryOrderDetailById(eventHandleEntity.getOrderId());
                orderV2Service.doMeicanCancel(orderModel, eventHandleEntity.getId(), eventHandleEntity.getRetryNum());
            }else if(eventHandleEntity.getEventType() == EventType.ENERGY_CENTER_ROLLBACK_V2_ERROR){
                orderV2Service.doRollbackEnergyCenterErrorEvent(eventHandleEntity.getExtend1(),
                        eventHandleEntity.getId(), eventHandleEntity.getRetryNum());
            }else if(eventHandleEntity.getEventType() == EventType.MEICAN_NEW_V2_ORDER){
                BoxOrderEntity orderModel = boxOrderService.getById(eventHandleEntity.getOrderId());
                if(!orderV2Service.doMeicanAddOrder(orderModel, eventHandleEntity.getId(), eventHandleEntity.getRetryNum())){
                    meicanAddOrderErrorNum++;
                }
            } else if(eventHandleEntity.getEventType() == EventType.ZHIPAN_SYNC_ERROR){
                KsCanteenConsumeRecordEntity ksCanteenConsumeRecordEntity = ksCanteenConsumeRecordService.lambdaQuery()
                        .eq(KsCanteenConsumeRecordEntity::getOrderNo, eventHandleEntity.getOrderCode())
                        .one();
                orderV2Service.doZhiPanSyncErrorEvent(ksCanteenConsumeRecordEntity, eventHandleEntity.getId(), eventHandleEntity.getRetryNum());
            } else if(eventHandleEntity.getEventType() == EventType.COFFEE_CONSUME_CANCEL){
                tradeRecordV2Service.doCoffeeRefundEvent(eventHandleEntity);
            }
        }
        if(meicanAddOrderErrorNum > 5){
            //如果美餐下单超过10笔，通知管理员
            orderService.sendWxMessage(SYSTEM_MESSAGE_RECEIVE_USERS, String.format("定时任务有五笔美餐订单下单失败"));
        }
    }
```

- 4.2 **取消美餐事件处理** --- 继续调用美餐系统的取消订单接口，如果仍然取消失败，会更新事件表的当前事件的状态和重试次数，如果超过3次会发信息给开发者进行手动处理。

```java
/**
     *
     * @param order
     * @param eventId
     * @param retryNum
     * 美餐重复取消返回数据结构: {"data":{"orderId":"a489a2d936"},
     * "resultCode":"NOT_FOUND","resultDescription":"apiErrors.corpOrderUserNotFound"}
     */
    public void doMeicanCancel(OrderModel order, Long eventId, Integer retryNum) {
        //取消菜单
        if(StringUtils.isBlank(order.getMeicanOrderId())){
            //如果没有美餐订单id直接跳过
            EventHandleEntity eventHandleEntity = new EventHandleEntity();
            eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLED);
            iEventHandleService.updateById(eventHandleEntity);
            return;
        }
        CancelOrderDto cancelOrderDto = meiCanV2Service.cancelOrder(order.getCorp(), order.getMeicanOrderId());
        if (cancelOrderDto == null || !(MEICAN_OK.equals(cancelOrderDto.getResultCode()) ||
                DELETE_CODE.equals(cancelOrderDto.getResultCode()))){
            if(++retryNum >=3){
                EventHandleEntity eventHandleEntity = new EventHandleEntity();
                eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLE_ERROR).setRetryNum(retryNum);
                iEventHandleService.updateById(eventHandleEntity);
                sendWxMessage(SYSTEM_MESSAGE_RECEIVE_USERS, String.format("美餐取消连续失败三次, 订单号: %s, 事件id: %s,"
                        + " 异常信息: %s", order.getId(), eventId, cancelOrderDto == null? "":cancelOrderDto.getResultCode()));
                log.error("美餐取消连续失败三次, 订单信息为[{}], 事件id[{}]", GsonUtils.toJson(order), eventId);
            }else{
                EventHandleEntity eventHandleEntity = new EventHandleEntity();
                eventHandleEntity.setId(eventId).setRetryNum(retryNum);
                iEventHandleService.updateById(eventHandleEntity);
            }
        }else{
            EventHandleEntity eventHandleEntity = new EventHandleEntity();
            eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLED);
            iEventHandleService.updateById(eventHandleEntity);
            if (statusCanCanceled(order.getStatus())) {
                log.warn("订单状态被覆盖：{}", order.getId());
                BoxOrderEntity boxOrderEntity = new BoxOrderEntity();
                boxOrderEntity.setId(order.getId());
                boxOrderEntity.setStatus(OrderStatus.USER_CANCEL.getCode());
                boxOrderService.updateById(boxOrderEntity);
            }
        }
    }
```

### 3. 举例 -- 下单

1. 首先进行条件判断：园区是否在食堂园区数据库？订餐日期是否合法？判断数量是否非法？判断券是否够扣？判断工卡状态？
2. 下单 --- 在调用下单方法时抛出异常都会进行回滚 rollbackMeicanMeal(rollBackParamDto);
```java
    public void doOrderMeal(List<MealOrderV2Vo> mealOrderVos, EnergyAccountDto energyAccountDto, String username, String garden){
        RollBackParamDto rollBackParamDto = new RollBackParamDto();
        try {
            // 假日餐和下午茶没有了
            //orderCanteenMealAndAfternoonTea(getHolidayMealVoList(mealOrderVos), mdataUserModelCidDto, garden, rollBackParamDto);
            orderMeaicanMeal(username, mealOrderVos, garden, rollBackParamDto);
        }catch (BusinessException e){
            //rollbackHolidayMeal(mdataUserModelCidDto, rollBackParamDto);
            rollbackMeicanMeal(rollBackParamDto);
            log.error("orderMeal error", e);
            throw e;
        }catch (Exception e){
            //rollbackHolidayMeal(mdataUserModelCidDto, rollBackParamDto);
            rollbackMeicanMeal(rollBackParamDto);
            log.error("orderMeal error", e);
            throw new BusinessException("订餐失败");
        }
    }
```

- 2.1 如果下单逻辑没有问题，就会在本地事件表中存储美餐下单事件；
- 2.2 如果下单逻辑出错，就会执行回滚方法 rollbackMeicanMeal(rollBackParamDto) --- 回滚菜品和餐柜库存以及订单信息

```java
    private void rollbackMeicanMeal(RollBackParamDto rollBackParamDto) {
        try {
            if(!CollectionUtils.isEmpty(rollBackParamDto.getAlreadySuccessMeicanOrder4RollbackList())){
                orderV2Service.rollbackMeicanOrder(
                        rollBackParamDto.getAlreadySuccessMeicanOrder4RollbackList());
            }
            if(!CollectionUtils.isEmpty(rollBackParamDto.getDishId2CountMap())){
                orderV2Service.rollbackRemainBoxDishAmount(rollBackParamDto.getDishId2CountMap());
            }
            if(!CollectionUtils.isEmpty(rollBackParamDto.getSideboard2CountMap())){
                orderV2Service.rollbackRemainSideboardBoxAmount(rollBackParamDto.getSideboard2CountMap());
            }
        } catch (Exception e) {
            baseService.sendWxMessage(BaseConstants.SYSTEM_MESSAGE_RECEIVE_USERS,
                    String.format("MealReservationService -> rollbackMeicanMeal 回滚美餐失败,"
                                    + " orders: %s, dishId2CountMap: %s, sideboard2CountMap: %s",
                            rollBackParamDto.getAlreadySuccessMeicanOrder4RollbackList(),
                            rollBackParamDto.getDishId2CountMap(), rollBackParamDto.getSideboard2CountMap()));
        }
    }
```

 - 2.3 rollbackMeicanOrder() --- 包括存储美餐取消失败事件，取消一卡通消费信息失败后保存能量券回滚失败事件以及更新数据库状态。
```java
    /**
     * 取消已定的订单信息
     *
     * @param orderSnapShotList 订单信息
     */
    public void rollbackMeicanOrder(List<OrderV2SnapShot> orderSnapShotList) {
        cancelMeiCanOrder(orderSnapShotList);
        //取消一卡通消费信息
        cancelEnergyCenterPay(orderSnapShotList);
        //更新数据库状态
        orderSnapShotList.forEach(e -> {
            orderMapper.updateStatusById(e.getId(), OrderStatus.SYSTEM_CANCEL.getCode());
        });

    }
```

3. 处理美餐下单事件 --- 尝试下单3次，如果3次均为下单成功，需要进行菜品、餐格库存回滚、订单状态也要为下单失败并告知用户
```java
    public boolean doMeicanAddOrder(BoxOrderEntity order, Long eventId, Integer retryNum) {
        //获取餐柜地址id
        try {
            QueryWrapper<BoxSideboardEntity> queryWrapper = new QueryWrapper<>();
            queryWrapper.eq("location", order.getLocation()).eq("corp", order.getCorp())
                    .eq("edible_time", order.getEdibleTime()).last("limit 1");
            BoxSideboardEntity boxSideboardEntity = boxSideboardService.getOne(queryWrapper);

            if(!order.getStatus().equals(OrderStatus.ORDERING.getCode())){
                EventHandleEntity eventHandleEntity = new EventHandleEntity();
                eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLED);
                iEventHandleService.updateById(eventHandleEntity);
                //只有预定中的订单需要继续美餐下单，如果不做这个限制会出现bug：如果下了两笔订单，第一笔美餐失败后台处理，第二笔智盘失败需要回滚第一笔订单，此时就会出现bug，美餐失败的后台处理结果会覆盖回滚操作
                return true;
            }
            OrderDto orderDto = meiCanV2Service.addOrder(order.getCorp(), boxSideboardEntity.getAddressId(), order.getUserName(),
                    order.getEdibleTime(), order.getMealType(), order.getSovellEmail(),
                    new CardDishDto().setDishId(Integer.valueOf(order.getMeicanDishId())).setCount(1).setPriceInCent(Integer.valueOf(order.getSovellPrice())));
            if (orderDto == null || orderDto.getData() == null || StringUtils.isBlank(orderDto.getData().getOrderId()) ||
                    !(MEICAN_OK.equals(orderDto.getResultCode()) || BaseConstants.MULTI_MEICAN_ORDER.equals(orderDto.getResultCode()))){
                //重试三次
                if(++retryNum >=3){
                    //事件置于为已处理
                    EventHandleEntity eventHandleEntity = new EventHandleEntity();
                    eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLE_ERROR).setHandleExceptionMsg(GsonUtils.toJson(orderDto));
                    //保证幂等性，防止重复修改状态，两个任务同时拿到这条记录，更新两次就会有问题
                    if(iEventHandleService.updateById(eventHandleEntity)){
                        //菜品库存回滚
                        log.info("dish num rollback");
                        rollbackDishStock(order);
                        //餐格库存回滚
                        boxSideboardMapper.updateStockById(boxSideboardEntity.getId(), -1);
                        //取消智盘
                        log.info("异步取消智盘");
                        asynEnergyCenterCancel(order);
                        //订单状态置为订餐失败
                        log.info("更新订单状态");
                        BoxOrderEntity boxOrderEntity = new BoxOrderEntity();
                        boxOrderEntity.setId(order.getId());
                        boxOrderEntity.setStatus(OrderStatus.ORDER_ERROR.getCode());
                        boxOrderService.updateById(boxOrderEntity);
                    }
                    //告知用户
                    sendWxCardMessage(order.getUserAccount(), WxCardMessage.ORDER_ERROR_TITLE,
                            String.format(WxCardMessage.ORDER_ERROR_DESCRIPTION, getDateDesc(order.getEdibleTime()),
                                    getMealTypeDesc(order.getMealType()), order.getDishName()),
                            String.format(WxCardMessage.ORDER_ERROR_URL, casUrl), WxCardMessage.ORDER_ERROR_BTNTXT);
                }else{
                    EventHandleEntity eventHandleEntity = new EventHandleEntity();
                    eventHandleEntity.setId(eventId).setRetryNum(retryNum);
                    iEventHandleService.updateById(eventHandleEntity);
                }
                return false;
            }else{
                EventHandleEntity eventHandleEntity = new EventHandleEntity();
                eventHandleEntity.setId(eventId).setHandleStatus(EventHandleStatus.HANDLED);
                if(iEventHandleService.updateById(eventHandleEntity)){
                    BoxOrderEntity boxOrderEntity = new BoxOrderEntity();
                    boxOrderEntity.setId(order.getId());
                    boxOrderEntity.setMeicanOrderId(orderDto.getData().getOrderId());
                    boxOrderEntity.setStatus(OrderStatus.ORDERED.getCode());
                    boxOrderService.updateById(boxOrderEntity);
                }
                return true;
            }
        }catch (Exception e){
            String stackTrace = getStackTrace(e);
            log.error("美餐下单异常: {}", stackTrace);
            sendWxMessage(BaseConstants.SYSTEM_MESSAGE_RECEIVE_USERS, String.format("美餐下单异常: %s", stackTrace));
            return false;
        }
    }
```